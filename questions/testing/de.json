[{"id":1,"question":" Was ist der Output?","codeSnippet":"function sayHi() {\n\tconsole.log(name);\n\tconsole.log(age);\n\tvar name = \"Lydia\";\n\tlet age = 21;\n}\n\nsayHi();","answerOptions":{"A":"`Lydia` und `undefined`","B":"`Lydia` und `ReferenceError`","C":"`ReferenceError` und `21`","D":"`undefined` und `ReferenceError`"},"correctAnswer":"D","answerExplanation":"Innerhalb der Funktion wird zuerst der `name` mit dem `var` Keyword gesetzt. Das bedeuted, dass die Variable mit dem Standardwert `undefined` gehoisted wird (Speicher wird während der Erstellung bereitgestellt), bis zu der Zeile, wo wir die Variable definieren. Da wir die Variable auf der Zeile, wo wir den `name` loggen noch nicht gesetzt haben, ist dieser noch `undefined`.\n\nVariablen mit dem `let` (oder `const`) Keyword werden ebenfalls gehoisted, aber im Gegensatz zu `var` werden diese nicht <i>initialisiert</i>. Auf sie können wir daher nicht zugreifen, bevor sie definiert wurden. JavaScript wirft einen `ReferenceError` aus."},{"id":2,"question":" Was ist der Output?","codeSnippet":"for (var i = 0; i < 3; i++) {\n\tsetTimeout(() => console.log(i), 1);\n}\n\nfor (let i = 0; i < 3; i++) {\n\tsetTimeout(() => console.log(i), 1);\n}","answerOptions":{"A":"`0 1 2` und `0 1 2`","B":"`0 1 2` und `3 3 3`","C":"`3 3 3` und `0 1 2`"},"correctAnswer":"C","answerExplanation":"Aufgrund der Event Queue in JavaScript, wird die Callback Funktion in `setTimeout` _nach_ der Schleife ausgeführt. Da die Variable `i` in der ersten Schleife mit dem `var` Keyword definiert wurde, ist dieser Wert global verfügbar. Während der Schleife wird der Wert von `i` jedesmal mithilfe des `++` Operators um `1` erhöht. Zu dem Zeitpunkt, wenn die Callback Funktion in `setTimeout` aufgerufen wird, ist `i` gleich `3` im ersten Beispiel.\n\nIn der zweiten Schleife wurde die Variable `i` mit dem `let` Keyword definiert: Variablen, die mit `let` (oder `const`) deklariert werden sind block-scoped (Ein Block ist alles zwischen `{ }`). Während jedem Durchlauf bekommt `i` einen neuen Wert zugewiesen, der jeweils innerhalb des Scopes der Schleife liegt."},{"id":3,"question":" Was ist der Output?","codeSnippet":"const shape = {\n\tradius: 10,\n\tdiameter() {\n\t\treturn this.radius * 2;\n\t},\n\tperimeter: () => 2 * Math.PI * this.radius,\n};\n\nshape.diameter();\nshape.perimeter();","answerOptions":{"A":"`20` und `62.83185307179586`","B":"`20` und `NaN`","C":"`20` und `63`","D":"`NaN` und `63`"},"correctAnswer":"B","answerExplanation":"Merke, dass der Wert von `diameter` eine reguläre Funktion ist, während der Wert von `perimeter` eine Arrow Function ist.\n\nIn Arrow Functions bezieht sich das `this` Keyword auf den aktuellen Scope, was bei regulären Funktionen nicht der Fall ist. Das bedeutet, wenn wir `perimeter` aufrufen, bezieht es sich nicht auf das shape Object, sondern auf den umliegenden Scope (zum Beispiel `window`).\n\nEs gibt keinen Wert `radius` in dem Object, daher wird `undefined` zurückgegeben."},{"id":4,"question":" Was ist der Output?","codeSnippet":"+true;\n!\"Lydia\";","answerOptions":{"A":"`1` und `false`","B":"`false` und `NaN`","C":"`false` und `false`"},"correctAnswer":"A","answerExplanation":"Das unäre Plus versucht einen Operand zu einer Nummer umzuwandeln. `true` ist `1` und `false` ist `0`.\n\nDer String `'Lydia'` ist truthy. Was wir eigentlich fragen ist: \"ist dieser truthy Wert falsy?\". Die Antwort ist `false`."},{"id":5,"question":" Was ist wahr?","codeSnippet":"const bird = {\n\tsize: \"small\",\n};\n\nconst mouse = {\n\tname: \"Mickey\",\n\tsmall: true,\n};","answerOptions":{"A":"`mouse.bird.size` ist nicht korrekt","B":"`mouse[bird.size]` ist nicht korrekt","C":"`mouse[bird[\"size\"]]` ist nicht korrekt","D":"Keine der Antworten ist korrekt."},"correctAnswer":"A","answerExplanation":"In JavaScript sind alle Object Keys strings (außer bei Symbols). Selbst wenn diese nicht als strings _getyped_ sind, werden sie im Endeffekt zu Strings konvertiert.\n\nJavaScript interpretiert lediglich Aussagen. Wenn wir Bracket Notation verwenden, sieht JavaScript so zuerst eine öffnende eckige Klammer `[` und geht weiter, bis es eine schließende eckige Klammer `]` findet. Erst dann wird die Aussage evaluiert.\n\n`mouse[bird.size]`: Erst wird `bird.size` evaluiert, was `\"small\"` zurück gibt. `mouse[\"small\"]` gibt `true` zurück.\n\nMit der Dot Notation ist das nicht der Fall. `mouse` hat keinen Key namens `bird`, was bedeutet, dass `mouse.bird` `undefined` ist. Dann fragen wir nach der `size` mit Dot Notation: `mouse.bird.size`. Da `mouse.bird` `undefined` ist, fragen wir eigentlich nach `undefined.size`. Das ist fehlerhaft und wirft daher einen Fehler, wie zum Beispiel `Cannot read property \"size\" of undefined` zurück."},{"id":6,"question":" Was ist der Output?","codeSnippet":"let c = { greeting: \"Hey!\" };\nlet d;\n\nd = c;\nc.greeting = \"Hello\";\nconsole.log(d.greeting);","answerOptions":{"A":"`Hello`","B":"`Hey`","C":"`undefined`","D":"`ReferenceError`","E":"`TypeError`"},"correctAnswer":"A","answerExplanation":"In JavaScript interagieren alle Objekte durch _Referenz_, wenn diese gleich sind.\n\nZuerst hält die Variable `c` ein Object. Später wird `d` die selbe Referenz zugewiesen wie `c`.\n\n<img src=\"https://i.imgur.com/ko5k0fs.png\" width=\"200\">\n\nWenn ein Object geändert wird, werden alle Referenzen zu diesem Object ebenfalls aktualisiert."},{"id":7,"question":" Was ist der Output?","codeSnippet":"let a = 3;\nlet b = new Number(3);\nlet c = 3;\n\nconsole.log(a == b);\nconsole.log(a === b);\nconsole.log(b === c);","answerOptions":{"A":"`true` `false` `true`","B":"`false` `false` `true`","C":"`true` `false` `false`","D":"`false` `true` `true`"},"correctAnswer":"C","answerExplanation":"`new Number()` ist ein eingebauter Function Constructor. Auch wenn der Wert wie eine Nummer aussieht, ist es in Wirklichkeit keine Nummer, sondern beinhaltet eine Menge zusätzlicher Werte und ist daher ein Object.\n\nWenn wir `==` nutzen wird nur geprüft, ob der _Wert_ gleich ist. Da beide den Wert `3` haben, wird `true` zurückgegeben.\n\nWenn wir aber `===` nutzen müssen sowohl der Wert _als auch_ der Typ übereinstimmen. Das ist `false`, da `new Number()` keine Nummer, sondern ein **Object** ist."},{"id":8,"question":" Was ist der Output?","codeSnippet":"class Chameleon {\n\tstatic colorChange(newColor) {\n\t\tthis.newColor = newColor;\n\t\treturn this.newColor;\n\t}\n\n\tconstructor({ newColor = \"green\" } = {}) {\n\t\tthis.newColor = newColor;\n\t}\n}\n\nconst freddie = new Chameleon({ newColor: \"purple\" });\nfreddie.colorChange(\"orange\");","answerOptions":{"A":"`orange`","B":"`purple`","C":"`green`","D":"`TypeError`"},"correctAnswer":"D","answerExplanation":"Die `colorChange` Funktion ist statisch (`static`). Statische Methoden existieren nur am Constructor wo sie erstellt wurden und können nicht an ihre Kinder weitergegeben werden. Da `freddie` ein Kind ist, wird die Funktion nicht runter gereicht und ist daher auch nicht in der `freddie` Instanz verfügbar. Ein `TypeError` wird zurückgeworfen."},{"id":9,"question":" Was ist der Output?","codeSnippet":"let greeting;\ngreetign = {}; // Typo!\nconsole.log(greetign);","answerOptions":{"A":"`{}`","B":"`ReferenceError: greetign is not defined`","C":"`undefined`"},"correctAnswer":"A","answerExplanation":"Das Object wird geloggt, da wir ein leeres Object am globalen Object erstellt haben. Als wir uns bei `greeting` verschrieben haben (als `greetign`) hat JavaScript das als neues Objekt `global.greetign = {}` (oder `window.greetign = {}` im Browser) angesehen.\n\nUm das zu verhindern, können wir `\"use strict\"` verwenden. Das stellt sicher, dass eine Variable erst definiert sein muss, bevor dieser ein Wert zugewiesen werden kann."},{"id":10,"question":" Was passiert, wenn wir das tun?","codeSnippet":"function bark() {\n\tconsole.log(\"Woof!\");\n}\n\nbark.animal = \"dog\";","answerOptions":{"A":"Nichts, das ist absolut in Ordnung.","B":"`SyntaxError`. Man kann einer Funktion keine Properties in der Form zuweisen.","C":"`undefined`","D":"`ReferenceError`"},"correctAnswer":"A","answerExplanation":"In JavaScript ist das ohne Weiteres möglich, da Funktionen Objekte sind. (Alle Typen außer primitiven Typen sind Objekte)\n\nEine Funktion ist ein spezieller Typ eines Objekts. Der Code, den wir schreiben ist keine eigentliche Funktion, sondern ein Object mit Properties. Die Property ist aufrufbar."},{"id":11,"question":" Was ist der Output?","codeSnippet":"function Person(firstName, lastName) {\n\tthis.firstName = firstName;\n\tthis.lastName = lastName;\n}\n\nconst member = new Person(\"Lydia\", \"Hallie\");\nPerson.getFullName = function() {\n\treturn `${this.firstName} ${this.lastName}`;\n};\n\nconsole.log(member.getFullName());","answerOptions":{"A":"`TypeError`","B":"`SyntaxError`","C":"`Lydia Hallie`","D":"`undefined` `undefined`"},"correctAnswer":"A","answerExplanation":"Man kann keine Properties einem Constructor zuweisen, wie es bei normalen Objects der Fall ist. Wenn man ein Feature allen Objects zugleich zuweisen möchte, muss man den Prototype verwenden. In diesem Fall also:\n\n```js\nPerson.prototype.getFullName = function() {\n\treturn `${this.firstName} ${this.lastName}`;\n};\n```\n\nSo hätte `member.getFullName()` funktioniert. Warum ist das von Vorteil? Sagen wir, wir hätten diese Methode dem Constructor selbst zugewiesen, aber vielleicht benötigt nicht jede Instanz von `Person` diese Methode. So hätte das eine Menge Arbeitsspeicher verschwendet, weil jede Instanz die Property zugewiesen bekommt, auch wenn sie diese gar nicht benötigt.\nStattdessen haben wir sie nur dem Prototype zugewiesen, sodass sie nur an einer Stelle im Arbeitsspeicher hinterlegt ist, aber dennoch haben alle Instanzen Zugriff darauf."},{"id":12,"question":" Was ist der Output?","codeSnippet":"function Person(firstName, lastName) {\n\tthis.firstName = firstName;\n\tthis.lastName = lastName;\n}\n\nconst lydia = new Person(\"Lydia\", \"Hallie\");\nconst sarah = Person(\"Sarah\", \"Smith\");\n\nconsole.log(lydia);\nconsole.log(sarah);","answerOptions":{"A":"`Person {firstName: \"Lydia\", lastName: \"Hallie\"}` und `undefined`","B":"`Person {firstName: \"Lydia\", lastName: \"Hallie\"}` und `Person {firstName: \"Sarah\", lastName: \"Smith\"}`","C":"`Person {firstName: \"Lydia\", lastName: \"Hallie\"}` und `{}`","D":"`Person {firstName: \"Lydia\", lastName: \"Hallie\"}` und `ReferenceError`"},"correctAnswer":"A","answerExplanation":"Für `sarah` haben wir nicht das `new` Keyword verwendet. Wenn wir `new` verwenden, bezieht sich das auf das neue, leere Object, welches wir erstellen. Wenn wir allerdings das `new` Keyword nicht verwenden, bezieht es sich auf das **globale Objekt**.\n\nWir haben `this.firstName` den Wert `\"Sarah\"` zugewiesen und `this.lastName` den Wert `\"Smith\"`. Was wir damit eigentlich zugewiesen haben, ist `global.firstName = 'Sarah'` und `global.lastName = 'Smith'`. `sarah` selbst ist daher `undefined`."},{"id":13,"question":" Was sind die drei Phasen der Event Propagation?","codeSnippet":null,"answerOptions":{"A":"Target > Capturing > Bubbling","B":"Bubbling > Target > Capturing","C":"Target > Bubbling > Capturing","D":"Capturing > Target > Bubbling"},"correctAnswer":"D","answerExplanation":"Während der **capturing** Phase geht das Event durch die Elternelemente bis hin zum Zielelement. Wenn dann das Ziel (**target**) erreicht ist, beginnt die **bubbling** Phase.\n\n<img src=\"https://i.imgur.com/N18oRgd.png\" width=\"200\">"},{"id":14,"question":" Alle Objekte haben Prototypes.","codeSnippet":null,"answerOptions":{"A":"wahr","B":"falsch"},"correctAnswer":"B","answerExplanation":"Alle Objekte haben Prototypes, außer dem **Basis Objekt**. Das Basis Objekt hat Zugriff auf einige Methoden und Properties, wie zum Beispiel `.toString`. Das ist der Grund, warum wir eingebaute JavaScript Methoden nutzen können. All diese Methoden sind am Prototype verfügbar. Obwohl JavaScript diese nicht direkt am Objekt finden kann, folgt es der Prototype Chain, bis es die Property findet und damit verfügbar macht."},{"id":15,"question":" Was ist der Output?","codeSnippet":"function sum(a, b) {\n\treturn a + b;\n}\n\nsum(1, \"2\");","answerOptions":{"A":"`NaN`","B":"`TypeError`","C":"`\"12\"`","D":"`3`"},"correctAnswer":"C","answerExplanation":"JavaScript ist eine **Sprache mit dynamischen Typen**, was bedeutet, dass wir Variablen keine spezifischen Typen zuweisen. Werte können automatisch in einen anderen Typ umgewandelt werden, was _implicit type coercion_ genannt wird. **Coercion** (dt. \"Zwang\") ist die Umwandlung von einem Typ zu einem anderen.\n\nIn diesem Beispiel wandelt JavaScript die Nummer `1` in einem String um, sodass die Funktion Sinn ergibt und einen Wert zurückgeben kann. Während der Addition eines numerischen Types (`1`) mit einem String (`'2'`) wird die Nummer wie ein String behandelt. Wir können Strings mit einem Plus Symbol zusammensetzen, zum Beispiel: `\"Hello\" + \"World\"`. Genau das passiert hier, sodass `\"1\" + \"2\"` einen Wert von `\"12\"` zurückgibt."},{"id":16,"question":" Was ist der Output?","codeSnippet":"let number = 0;\nconsole.log(number++);\nconsole.log(++number);\nconsole.log(number);","answerOptions":{"A":"`1` `1` `2`","B":"`1` `2` `2`","C":"`0` `2` `2`","D":"`0` `1` `2`"},"correctAnswer":"C","answerExplanation":"Der **Postfix** Unary Operator `++`:\n\n1. gibt den Wert zurück (hier: `0`)\n2. erhöht den Wert (`number` ist jetzt `1`)\n\nDer **Prefix** Unary Operator `++`:\n\n1. erhöht den Wert (`number` ist jetzt `2`)\n2. gibt den Wert zurück (hier: `2`)\n\nDer Output ist daher `0 2 2`."},{"id":17,"question":" Was ist der Output?","codeSnippet":"function getPersonInfo(one, two, three) {\n\tconsole.log(one);\n\tconsole.log(two);\n\tconsole.log(three);\n}\n\nconst person = \"Lydia\";\nconst age = 21;\n\ngetPersonInfo`${person} is ${age} years old`;","answerOptions":{"A":"`\"Lydia\"` `21` `[\"\", \" is \", \" years old\"]`","B":"`[\"\", \" is \", \" years old\"]` `\"Lydia\"` `21`","C":"`\"Lydia\"` `[\"\", \" is \", \" years old\"]` `21`"},"correctAnswer":"B","answerExplanation":"Wenn man Template Literals verwendet ist das erste Argument immer ein Array der String Werte. Die restlichen Argumente bekommen die Werte der übergebenen Expressions zugewiesen."},{"id":18,"question":" Was ist der Output?","codeSnippet":"function checkAge(data) {\n\tif (data === { age: 18 }) {\n\t\tconsole.log(\"You are an adult!\");\n\t} else if (data == { age: 18 }) {\n\t\tconsole.log(\"You are still an adult.\");\n\t} else {\n\t\tconsole.log(`Hmm.. You don't have an age I guess`);\n\t}\n}\n\ncheckAge({ age: 18 });","answerOptions":{"A":"`You are an adult!`","B":"`You are still an adult.`","C":"`Hmm.. You don't have an age I guess`"},"correctAnswer":"C","answerExplanation":"Wenn man prüft, ob Werte gleich sind werden Primitives immer anhand ihrer _Value_ verglichen, während Objects anhand der _Referenz_ verglichen werden. JavaScript prüft, ob die Objekte eine Referenz zur gleichen Stelle im Speicher haben.\n\nDie beiden Objekte, die wir hier vergleichen haben das nicht. Das Objekt, welches wir als Parameter übergeben haben bezieht sich auf eine andere Stelle im Speicher, als das Objekt, welches wir verwendet haben um die Werte zu vergleichen.\n\nDeshalb werfen sowohl `{ age: 18 } === { age: 18 }` als auch `{ age: 18 } == { age: 18 }` den Wert `false` zurück."},{"id":19,"question":" Was ist der Output?","codeSnippet":"function getAge(...args) {\n\tconsole.log(typeof args);\n}\n\ngetAge(21);","answerOptions":{"A":"`\"number\"`","B":"`\"array\"`","C":"`\"object\"`","D":"`\"NaN\"`"},"correctAnswer":"C","answerExplanation":"Der Spread Operator (`...args`) gibt ein Array mit Argumenten zurück. Ein Array ist ein Objekt, sodass `typeof args` `\"object\"` ausgibt."},{"id":20,"question":" Was ist der Output?","codeSnippet":"function getAge() {\n\t\"use strict\";\n\tage = 21;\n\tconsole.log(age);\n}\n\ngetAge();","answerOptions":{"A":"`21`","B":"`undefined`","C":"`ReferenceError`","D":"`TypeError`"},"correctAnswer":"C","answerExplanation":"Durch `\"use strict\"` kann man sicher stellen, dass man nicht versehentlich globale Variablen definiert. Da wir die Variable `age` nie definiert haben und `\"use strict\"` verwenden wirft JavaScript einen reference error aus. Hätten wir `\"use strict\"` nicht verwendet, so hätte es funktioniert, da die property `age` dem globalen Objekt zugewiesen worden wäre."},{"id":21,"question":" Was ist der Wert von `sum`?","codeSnippet":"const sum = eval(\"10*10+5\");","answerOptions":{"A":"`105`","B":"`\"105\"`","C":"`TypeError`","D":"`\"10*10+5\"`"},"correctAnswer":"A","answerExplanation":"`eval` evaluiert Code, der als String übergeben wurde. Falls es, wie in diesem Fall, eine Expression ist, so wird diese Expression auch evaluiert. Die Expression `10 * 10 + 5` gibt damit die nummer `105` aus."},{"id":22,"question":" Wie lange ist cool_secret verfügbar?","codeSnippet":"sessionStorage.setItem(\"cool_secret\", 123);","answerOptions":{"A":"Für immer, der Wert geht nicht verloren.","B":"Wenn der User den Tab schließt.","C":"Wenn der User den Browser schließt, nicht nur den Tab.","D":"Wenn der User den Computer neu startet."},"correctAnswer":"B","answerExplanation":"Der Wert in `sessionStorage` geht verloren, wenn der _Tab_ geschlossen wird.\n\nWenn man stattdessen `localStorage` verwendet, bleibt der Wert für immer bestehend, es sei denn `localStorage.clear()` wird ausgeführt."},{"id":23,"question":" Was ist der Output?","codeSnippet":"var num = 8;\nvar num = 10;\n\nconsole.log(num);","answerOptions":{"A":"`8`","B":"`10`","C":"`SyntaxError`","D":"`ReferenceError`"},"correctAnswer":"B","answerExplanation":"Mit dem `var` Keyword kann man mehrere Variablen mit dem selben Namen definieren. Die Variable hält dann den letzt gesetzten Wert.\n\nDas ist nicht möglich mit `let` oder `const`, da diese dem Block Scope unterliegen."},{"id":24,"question":" Was ist der Output?","codeSnippet":"const obj = { 1: \"a\", 2: \"b\", 3: \"c\" };\nconst set = new Set([1, 2, 3, 4, 5]);\n\nobj.hasOwnProperty(\"1\");\nobj.hasOwnProperty(1);\nset.has(\"1\");\nset.has(1);","answerOptions":{"A":"`false` `true` `false` `true`","B":"`false` `true` `true` `true`","C":"`true` `true` `false` `true`","D":"`true` `true` `true` `true`"},"correctAnswer":"C","answerExplanation":"Alle Object Keys (außgenommen Symbols) sind im Endeffekt Strings, selbst, wenn man diese nicht explizit als String definiert. Deshalb gibt `obj.hasOwnProperty('1')` auch `true` zurück.\n\nDas funktioniert nicht für Set. Da wir keine `'1'` in unserem Set haben wirft `set.has('1')` den Wert `false` zurück. Der Typ von `1` ist numerisch und `set.has(1)` gibt daher `true` zurück."},{"id":25,"question":" Was ist der Output?","codeSnippet":"const obj = { a: \"one\", b: \"two\", a: \"three\" };\nconsole.log(obj);","answerOptions":{"A":"`{ a: \"one\", b: \"two\" }`","B":"`{ b: \"two\", a: \"three\" }`","C":"`{ a: \"three\", b: \"two\" }`","D":"`SyntaxError`"},"correctAnswer":"C","answerExplanation":"Wenn man zwei Keys mit dem selben Namen hat, wird der erste Key ersetzt. Er wird immernoch an erster Stelle sein, allerdings mit dem zuletzt gesetzten Wert."},{"id":26,"question":" Der JavaScript Global Execution Context erstellt zwei Dinge: das globale Objekt und das \"this\" Keyword.","codeSnippet":null,"answerOptions":{"A":"wahr","B":"falsch","C":"kommt darauf an"},"correctAnswer":"A","answerExplanation":"Der Base Execution Context entspricht dem Global Execution Context und ist überall in unserem Code verfügbar."},{"id":27,"question":" Was ist der Output?","codeSnippet":"for (let i = 1; i < 5; i++) {\n\tif (i === 3) continue;\n\tconsole.log(i);\n}","answerOptions":{"A":"`1` `2`","B":"`1` `2` `3`","C":"`1` `2` `4`","D":"`1` `3` `4`"},"correctAnswer":"C","answerExplanation":"`continue` überspringt einen Durchlauf, wenn eine gewisse Bedingung erfüllt ist und `true` zurück gibt."},{"id":28,"question":" Was ist der Output?","codeSnippet":"String.prototype.giveLydiaPizza = () => {\n\treturn \"Just give Lydia pizza already!\";\n};\n\nconst name = \"Lydia\";\n\nname.giveLydiaPizza();","answerOptions":{"A":"`\"Just give Lydia pizza already!\"`","B":"`TypeError: not a function`","C":"`SyntaxError`","D":"`undefined`"},"correctAnswer":"A","answerExplanation":"`String` ist ein eingebauter Constructor, dem wir Properties zuweisen können. Wir haben hier seinem Prototype eine Methode hinzugefügt. Primitive strings werden automatisch durch die String Prototype Function in ein String Objekt umgewandelt. Daher haben alle Strings (String Objects) Zugriff auf diese Methode."},{"id":29,"question":" Was ist der Output?","codeSnippet":"const a = {};\nconst b = { key: \"b\" };\nconst c = { key: \"c\" };\n\na[b] = 123;\na[c] = 456;\n\nconsole.log(a[b]);","answerOptions":{"A":"`123`","B":"`456`","C":"`undefined`","D":"`ReferenceError`"},"correctAnswer":"B","answerExplanation":"Objekt Keys werden automatisch in Strings umgewandelt. Wir versuchen ein Objekt mit dem Wert `123` als Key dem Objekt `a` zuzuweisen.\n\nAllerdings wird ein Object, wenn es in einen String umgewandelt wird als `\"[object Object]\"` ausgegeben. Was wir hier also sagen ist, dass `a[\"object Object\"] = 123` ist. Wir versuchen das gleiche erneut - `c` ist ein anderes Objekt, welches wir implizit zu einem String umwandeln, sodass `a[\"object Object\"] = 456` ist.\n\nDann loggen wir `a[b]`, was eigentlich `a[\"object Object\"]` ist und gerade von uns zu `456` gesetzt wurde, sodass `456` ausgegeben wird."},{"id":30,"question":" Was ist der Output?","codeSnippet":"const foo = () => console.log(\"First\");\nconst bar = () => setTimeout(() => console.log(\"Second\"));\nconst baz = () => console.log(\"Third\");\n\nbar();\nfoo();\nbaz();","answerOptions":{"A":"`First` `Second` `Third`","B":"`First` `Third` `Second`","C":"`Second` `First` `Third`","D":"`Second` `Third` `First`"},"correctAnswer":"B","answerExplanation":"Wir haben eine `setTimeout` Funktion, die zuerst ausgeführt wird und dennoch als letztes ausgegeben wird.\n\nDer Grund dafür ist, dass Browser nicht nur die Runtime Engine, sondern auch eine `WebAPI` haben. Die `WebAPI` stellt uns `setTimeout` bereit.\n\nNachdem die _Callback Function_ an die WebAPI übergeben wurde wird `setTimeout` (aber nicht die Callback Function) ausgeführt und aus dem Stack entfernt.\n\n<img src=\"https://i.imgur.com/X5wsHOg.png\" width=\"200\">\n\nJetzt wird `foo` ausgeführt und `\"First\"` geloggt.\n\n<img src=\"https://i.imgur.com/Pvc0dGq.png\" width=\"200\">\n\n`foo` wird aus dem Stack entfernt und `baz` wird ausgeführt. `\"Third\"` wird geloggt.\n\n<img src=\"https://i.imgur.com/WhA2bCP.png\" width=\"200\">\n\nDie WebAPI kann nicht einfach Dinge zum Stack hinzufügen, wenn sie bereit ist, stattdessen wird die Callback Function zur _queue_ hinzugefügt.\n\n<img src=\"https://i.imgur.com/NSnDZmU.png\" width=\"200\">\n\nDas ist, wo die Event Loop ins Spiel kommt. Die **Event Loop** betrachtet den Stack und die Task Queue. Wenn der Stack leer ist wird das erste Element in der Queue zum Stack übertragen.\n\n<img src=\"https://i.imgur.com/uyiScAI.png\" width=\"200\">\n\n`bar` wird ausgeführt, `\"Second\"` wird geloggt und aus dem Stack entfernt."},{"id":31,"question":" Was ist event.target wenn ein Button geklickt wird?","codeSnippet":"html\n<div onclick=\"console.log('first div')\">\n\t<div onclick=\"console.log('second div')\">\n\t\t<button onclick=\"console.log('button')\">\n\t\t\tClick!\n\t\t</button>\n\t</div>\n</div>","answerOptions":{"A":"Äußerer `div`","B":"Innerer `div`","C":"`button`","D":"Ein Array mit allen genesteten Elementen"},"correctAnswer":"C","answerExplanation":"Das am tiefsten genestete Element, welches das Event auslöst ist das Event Target. Man kann den Bubbling Prozess mit `event.stopPropagation` anhalten."},{"id":32,"question":" Was ist der geloggte Output, wenn man auf den Paragraph klickt?","codeSnippet":"html\n<div onclick=\"console.log('div')\">\n\t<p onclick=\"console.log('p')\">\n\t\tClick here!\n\t</p>\n</div>","answerOptions":{"A":"`p` `div`","B":"`div` `p`","C":"`p`","D":"`div`"},"correctAnswer":"A","answerExplanation":"Wenn wir auf den Paragraph klicken, sehen wir zwei logs: `p` und `div`. Während der Event Propagation werden drei Phasen ausgeführt: capturing, target und bubbling. Standardmäßig werden Event Handler in der Bubbling Phase ausgeführt (es sei denn man setzt `useCapture` auf `true`). Die Ausführung beginnt vom tiefsten Element nach Außen."},{"id":33,"question":" Was ist der Output?","codeSnippet":"const person = { name: \"Lydia\" };\n\nfunction sayHi(age) {\n\tconsole.log(`${this.name} is ${age}`);\n}\n\nsayHi.call(person, 21);\nsayHi.bind(person, 21);","answerOptions":{"A":"`undefined is 21` `Lydia is 21`","B":"`function` `function`","C":"`Lydia is 21` `Lydia is 21`","D":"`Lydia is 21` `function`"},"correctAnswer":"D","answerExplanation":"In beiden Fällen können wir das Objekt weiter reichen, auf welches sich das `this` Keyword beziehen soll. Allerdings wird `.call` _sofort ausgeführt_.\n\n`.bind.` gibt eine _Kopie_ der Funktion mit gebundenem Context zurück und wird daher nicht sofort ausgeführt."},{"id":34,"question":" Was ist der Output?","codeSnippet":"function sayHi() {\n\treturn (() => 0)();\n}\n\ntypeof sayHi();","answerOptions":{"A":"`\"object\"`","B":"`\"number\"`","C":"`\"function\"`","D":"`\"undefined\"`"},"correctAnswer":"B","answerExplanation":"Die `sayHi` Funktion gibt den Wert der sofort ausgeführten Funktion (IIFE) zurück. Die Funktion gibt `0` zurück, was vom Typ `\"number\"` ist.\n\nEs gibt nur 7 eingebaute Typen in JavaScript: `null`, `undefined`, `boolean`, `number`, `string`, `object`, `symbol`, und `bigint`. `\"function\"` ist kein Typ, weil Funktionen Objekte sind und daher dem Typ `\"object\"` entsprechen."},{"id":35,"question":" Welcher dieser Werte ist falsy?","codeSnippet":"0;\nnew Number(0);\n(\"\");\n(\" \");\nnew Boolean(false);\nundefined;","answerOptions":{"A":"`0`, `''`, `undefined`","B":"`0`, `new Number(0)`, `''`, `new Boolean(false)`, `undefined`","C":"`0`, `''`, `new Boolean(false)`, `undefined`","D":"Alle sind falsy"},"correctAnswer":"A","answerExplanation":"Es gibt nur 6 falsy typen:\n\n- `undefined`\n- `null`\n- `NaN`\n- `0`\n- `''` (leerer String)\n- `false`\n\nFunktions-Constructor, wie `new Number` und `new Boolean` sind truthy."},{"id":36,"question":" Was ist der Output?","codeSnippet":"console.log(typeof typeof 1);","answerOptions":{"A":"`\"number\"`","B":"`\"string\"`","C":"`\"object\"`","D":"`\"undefined\"`"},"correctAnswer":"B","answerExplanation":"`typeof 1` gibt `\"number\"` zurück.\n`typeof \"number\"` gibt `\"string\"` zurück."},{"id":37,"question":" Was ist der Output?","codeSnippet":"const numbers = [1, 2, 3];\nnumbers[10] = 11;\nconsole.log(numbers);","answerOptions":{"A":"`[1, 2, 3, 7 x null, 11]`","B":"`[1, 2, 3, 11]`","C":"`[1, 2, 3, 7 x empty, 11]`","D":"`SyntaxError`"},"correctAnswer":"C","answerExplanation":"Wenn Werte einem Element in einem Array zugewiesen werden, die die Länge des Arrays übersteigen, so erstellt JavaScript \"empty slots\" (leere Stellen). Diese haben den Wert `undefined`, aber das Array sieht dann in etwa so aus:\n\n`[1, 2, 3, 7 x empty, 11]`\n\nabhängig davon wo das Array ausgeführt wird (die Ausgabe ist unterschiedlich für verschiedene Browser, Node, etc.)"},{"id":38,"question":" Was ist der Output?","codeSnippet":"(() => {\n\tlet x, y;\n\ttry {\n\t\tthrow new Error();\n\t} catch (x) {\n\t\t(x = 1), (y = 2);\n\t\tconsole.log(x);\n\t}\n\tconsole.log(x);\n\tconsole.log(y);\n})();","answerOptions":{"A":"`1` `undefined` `2`","B":"`undefined` `undefined` `undefined`","C":"`1` `1` `2`","D":"`1` `undefined` `undefined`"},"correctAnswer":"A","answerExplanation":"Der `catch` Block erhält ein Argument `x`. Das ist nicht das selbe `x` wie die Variable, der wir Argumente zuweisen. Die Variable `x` ist block-scoped.\n\nSpäter setzen wir die block-scoped Variable gleich `1`, und setzen ebenfalls den Wert der Variable `y`. Jetzt loggen wir die block-scoped Variable `x` mit dem Wert `1`.\n\nAußerhalb des `catch` Blocks ist `x` noch immer `undefined` und `y` ist `2`. Wenn wir `console.log(x)` außerhalb des `catch` Block ausführen, wird für `x` der Wert `undefined` und für `y` der Wert `2` geloggt."},{"id":39,"question":" Alles in JavaScript ist entweder ein ...","codeSnippet":null,"answerOptions":{"A":"Primitive oder Object","B":"Function oder Object","C":"Fangfrage: nur Objects!","D":"Number oder Object"},"correctAnswer":"A","answerExplanation":"JavaScript hat nur primitive Typen und Objekte.\n\nPrimitive Typen sind `boolean`, `null`, `undefined`, `bigint`, `number`, `string`, und `symbol`.\n\nWas einen primitiven Typ von einem Objekt unterscheidet ist, dass Primitive keine Properties oder Methoden haben, obwohl zum Beispiel `'foo'.toUpperCase()` zu `'FOO'` wird und keinen `TypeError` auswirft. Der Grund dafür ist, wenn man eine Property oder Method an einem primitiven Typ wie einem String ausführt, legt JavaScript eine Wrapper Class um das String Objekt, die danach sofort wieder entfernt wird, wenn die Expression ausgeführt wurde. Alle primitiven Typen außer `null` und `undefined` weisen dieses Verhalten auf."},{"id":40,"question":" Was ist der Output?","codeSnippet":"[[0, 1], [2, 3]].reduce(\n\t(acc, cur) => {\n\t\treturn acc.concat(cur);\n\t},\n\t[1, 2],\n);","answerOptions":{"A":"`[0, 1, 2, 3, 1, 2]`","B":"`[6, 1, 2]`","C":"`[1, 2, 0, 1, 2, 3]`","D":"`[1, 2, 6]`"},"correctAnswer":"C","answerExplanation":"`[1, 2]` ist unser ursprünglicher Wert. Zusammen mit dem ersten `acc` ist das der Wert, mit dem wir beginnen. Während dem ersten Durchlauf ist `acc` gleich `[1, 2]`, und `cur` ist `[0, 1]`. Wir verbinden diese, was `[1, 2, 0, 1]` ergibt.\n\nDann entspricht `acc` gleich `[1, 2, 0, 1]` und `cur` ist gleich `[2, 3]`. Wir verbinden diese und bekommen `[1, 2, 0, 1, 2, 3]`."},{"id":41,"question":" Was ist der Output?","codeSnippet":"!!null;\n!!\"\";\n!!1;","answerOptions":{"A":"`false` `true` `false`","B":"`false` `false` `true`","C":"`false` `true` `true`","D":"`true` `true` `false`"},"correctAnswer":"B","answerExplanation":"`null` ist falsy. `!null` gibt `true` zurück. `!true` gibt `false` zurück.\n\n`\"\"` ist falsy. `!\"\"` gibt `true` zurück. `!true` gibt `false` zurück.\n\n`1` ist truthy. `!1` gibt `false` zurück. `!false` gibt `true` zurück."},{"id":42,"question":" Was gibt die `setInterval` Method zurück?","codeSnippet":"setInterval(() => console.log(\"Hi\"), 1000);","answerOptions":{"A":"Eine unique id","B":"Die definierte Anzahl von Millisekunden","C":"Die Callback Function","D":"`undefined`"},"correctAnswer":"A","answerExplanation":"Es gibt eine unique id zurück. Diese id kann zum Beispiel verwendet werden um das Interval mit der `clearInterval()` Funktion zu leeren."},{"id":43,"question":" Was wird hier ausgegeben?","codeSnippet":"[...\"Lydia\"];","answerOptions":{"A":"`[\"L\", \"y\", \"d\", \"i\", \"a\"]`","B":"`[\"Lydia\"]`","C":"`[[], \"Lydia\"]`","D":"`[[\"L\", \"y\", \"d\", \"i\", \"a\"]]`"},"correctAnswer":"A","answerExplanation":"Ein String ist ein Iterable. Der Spread Operator mappt jedes Zeichen eines Iterables zu einem eigenen Element."},{"id":44,"question":" Was ist der Output?","codeSnippet":"function* generator(i) {\n  yield i;\n  yield i * 2;\n}\n\nconst gen = generator(10);\n\nconsole.log(gen.next().value);\nconsole.log(gen.next().value);","answerOptions":{"A":"`[0, 10], [10, 20]`","B":"`20, 20`","C":"`10, 20`","D":"`0, 10 und 10, 20`"},"correctAnswer":"C","answerExplanation":"Reguläre Funktionen können nicht angehalten werden, wenn sie bereits aufgerufen wurden. Eine Generator Funktion kann dagegen auch angehalten werden, nachdem sie aufgerufen wurde und später fortgesetzt werden, wo sie angehalten wurde. Jedes Mal, wenn eine Generator Funktion ein `yield` Keyword findet, wirft die Funktion den danach ermittelten Wert aus. Wichtig: _yield_ ist nichtdas selbe wie _return_.\n\nZuerst initialisieren wir die Generator Funktion mit `i` gleich `10`. Wir rufen die Generator Funktion mit der `next()` Methode auf. Beim ersten Aufruf der Generator Funktion is `i` gleich `10`. Wenn wir bei `yield` ankommen wird der Wert von `i` ausgegeben. Der Generator wird angehalten und `10` wird geloggt.\n\nDann wird die Funktion erneut mit der `next()` Methode aufgerufen und beginnt von dort, wo sie zuletzt angehalten wurde, nach wie vor mit `i` gleich `10`. Jetzt erreichen wir das nächste `yield` Keyword bei `i * 2`. `i` ist gleich `10`, sodass das Ergebnis von `10 * 2` ausgegeben wird, was `20` ist. Das Ergebnis ist `10, 20`."},{"id":45,"question":" Was wird hier ausgegeben?","codeSnippet":"const firstPromise = new Promise((res, rej) => {\n  setTimeout(res, 500, \"one\");\n});\n\nconst secondPromise = new Promise((res, rej) => {\n  setTimeout(res, 100, \"two\");\n});\n\nPromise.race([firstPromise, secondPromise]).then(res => console.log(res));","answerOptions":{"A":"`\"one\"`","B":"`\"two\"`","C":"`\"two\" \"one\"`","D":"`\"one\" \"two\"`"},"correctAnswer":"B","answerExplanation":"Wenn wir mehrere Promises in die `Promice.race` Methode eingegeben, wird das Promise, welches _zuerst_ gelöst/abgelehnt wird auch hier gelöst/abgelehnt. Die `setTimeout` Methode bekommt einen Timer von 500ms für das erste Promise (`firstPromise`) übergeben, und 100ms für das zweite Promise (`secondPromise`). Das bedeutet, dass `secondPromise` mit dem Wert `'two'` zuerst gelöst wird und an `res` übergeben wird. Der Wert wird geloggt."},{"id":46,"question":" Was ist der Output?","codeSnippet":"let person = { name: \"Lydia\" };\nconst members = [person];\nperson = null;\n\nconsole.log(members);","answerOptions":{"A":"`null`","B":"`[null]`","C":"`[{}]`","D":"`[{ name: \"Lydia\" }]`"},"correctAnswer":"D","answerExplanation":"Zuerst definieren wir die Variable `person` mit dem Wert eines Objekts, welches eine `name` Property hat.\n\n<img src=\"https://i.imgur.com/TML1MbS.png\" width=\"200\">\n\nDann definieren wir eine Variable namens `members`. Wir setzen das erste Element des Arrays gleich dem Wert der `person` Variable. Objekte interagieren durch eine _Referenz_, wenn diese gleichgesetzt werden. Wenn eine Referenz von einer Variable zur anderen gleichgesetzt wird, so wird eine _Kopie_ der Referenz erstellt (Wichtig: nicht die _selbe_ Referenz!)\n\n<img src=\"https://i.imgur.com/FSG5K3F.png\" width=\"300\">\n\nDann setzen wir die Variable `person` gleich `null`.\n\n<img src=\"https://i.imgur.com/sYjcsMT.png\" width=\"300\">\n\nWir ändern nur den Wert der Variable `person` und nicht das erste Element im Array, da das Element eine andere Referenz als das Objekt hat (Kopie). Das erste Element in `members` beinhaltet immernoch die Referenz zum original Objekt. Wenn wir das `members` Array loggen ist dieses immernoch der Wert des Objekts, welches dann geloggt wird."},{"id":47,"question":" Was ist der Output?","codeSnippet":"const person = {\n  name: \"Lydia\",\n  age: 21\n};\n\nfor (const item in person) {\n  console.log(item);\n}","answerOptions":{"A":"`{ name: \"Lydia\" }, { age: 21 }`","B":"`\"name\", \"age\"`","C":"`\"Lydia\", 21`","D":"`[\"name\", \"Lydia\"], [\"age\", 21]`"},"correctAnswer":"B","answerExplanation":"Mit einer `for-in` Schleife können wir über Objekt Keys iterieren - in diesem Fall `name` und `age`. Im Endeffekt sind Objekt Keys Strings (oder Symbols). Bei jedem Durchlauf setzen wir den Wert von `item` gleich zum aktuellen Key. Zuerst ist `item` gleich `name` und wird geloggt. Dann wird `item` gleich `age` gesetzt und wird geloggt."},{"id":48,"question":" Was ist der Output?","codeSnippet":"console.log(3 + 4 + \"5\");","answerOptions":{"A":"`\"345\"`","B":"`\"75\"`","C":"`12`","D":"`\"12\"`"},"correctAnswer":"B","answerExplanation":"Operator Assoziativität ist die Reihenfolge, in der der Compiler die Expression evaluiert, entweder links-nach-rechts oder rechts-nach-links. Das funktioniert nur, wenn alle Operatoren die _gleiche_ Priorität haben. Hier haben wir nur einen Operator: `+`. Für Addition ist die Assoziativität links-nach-rechts.\n\n`3 + 4` wird zuerst errechnet, das Ergebnis ist `7`.\n\n`7 + '5'` ergibt `\"75\"` (aufgrund von Coercion). JavaScript wandelt `7` in einen String um (Siehe Frage 15). Zwei Strings werden durch den `+` Operator zusammengesetzt.`\"7\" + \"5\"` ergibt `\"75\"`."},{"id":49,"question":" Was ist der Wert von `num`?","codeSnippet":"const num = parseInt(\"7*6\", 10);","answerOptions":{"A":"`42`","B":"`\"42\"`","C":"`7`","D":"`NaN`"},"correctAnswer":"C","answerExplanation":"Nur die erste Zahl im String wird ausgegeben. Aufgrund des _radix_ (das zweite Argument definiert, welchen Typ einer Zahl wir parsen wollen: Basis 10, hexadezimal, Octal, Binary, etc.) prüft `parseInt` ob die Zeichen im String gültig sind. Wenn ein Zeichen erkannt wird, welches nicht gültig ist, wird der Parse Vorgang beendet und die nachfolgenden Zeichen werden ignoriert.\n\n`*` ist keine gültige Nummer, sodass nur `\"7\"` als Dezimal geparsed wird: `7`. `num` ist jetzt gleich `7`."},{"id":50,"question":" Was ist der Output?","codeSnippet":"[1, 2, 3].map(num => {\n  if (typeof num === \"number\") return;\n  return num * 2;\n});","answerOptions":{"A":"`[]`","B":"`[null, null, null]`","C":"`[undefined, undefined, undefined]`","D":"`[ 3 x empty ]`"},"correctAnswer":"C","answerExplanation":"Wenn man über das Array mappt, ist `num` gleich dem Element, welches gerade durchlaufen wird. In diesem Fall sind die Elemente Nummern, sodass die Kondition der If-Schleife `typeof num === \"number\"` erfüllt ist und `true` zurück gibt. Die map Funktion erstellt ein neues Array und beinhaltet die Werte der Funktion.\n\nAllerdings geben wir keinen Wert aus. Wenn unsere Funktion keinen Wert ausgibt, ist der Standard \"return\" `undefined`. Für jedes Element im Array wird die Funktion aufgerufen, sodass für jedes Element `undefined` ausgegeben wird."},{"id":51,"question":" Was ist der Output?","codeSnippet":"function getInfo(member, year) {\n  member.name = \"Lydia\";\n  year = 1998;\n}\n\nconst person = { name: \"Sarah\" };\nconst birthYear = \"1997\";\n\ngetInfo(person, birthYear);\n\nconsole.log(person, birthYear);","answerOptions":{"A":"`{ name: \"Lydia\" }, \"1997\"`","B":"`{ name: \"Sarah\" }, \"1998\"`","C":"`{ name: \"Lydia\" }, \"1998\"`","D":"`{ name: \"Sarah\" }, \"1997\"`"},"correctAnswer":"A","answerExplanation":"Argumente werden als _Wert_ übergeben, es sei denn ihr Wert ist ein Objekt, dann werden sie als _Referenz_ übergeben. `birthYear` wird als Wert übergeben, da es ein String ist und kein Objekt. Wenn Argumente als Wert übergeben werden, wird eine _Kopie_ des Wertes erstellt (Siehe Frage 46).\n\nDie Variable `birthYear` beinhaltet eine Referenz zum Wert `\"1997\"`. Das Argument `year` beinhaltet ebenso eine Referenz zum Wert `\"1997\"`, aber die Werte sind nicht identisch! Wenn wir den Wert von `year` ändern, indem wir ihn gleich `\"1998\"` setzen, ändern wir nur den Wert von `year`. `birthYear` ist immernoch `\"1997\"`.\n\nDer Wert von `person` ist ein Objekt, sodass das Argument `member` eine Kopie der Referenz des _gleichen_ Objekts hat. Wenn wir also eine Property dessen Objekt `member` eine Referenz enthält, wird der Wert von `person` ebenso geändert, da beide die gleiche Referenz zum selben Objekt beinhalten. Die Property `name` von `person` ist jetzt gleich `\"Lydia\"`."},{"id":52,"question":" Was ist der Output?","codeSnippet":"function greeting() {\n  throw \"Hello world!\";\n}\n\nfunction sayHi() {\n  try {\n    const data = greeting();\n    console.log(\"It worked!\", data);\n  } catch (e) {\n    console.log(\"Oh no an error!\", e);\n  }\n}\n\nsayHi();","answerOptions":{"A":"`\"It worked! Hello world!\"`","B":"`\"Oh no an error: undefined\"`","C":"`SyntaxError: can only throw Error objects`","D":"`\"Oh no an error! Hello world!\"`"},"correctAnswer":"D","answerExplanation":"Mit dem `throw` Statement können wir individuelle Fehlermeldungen erstellen und Exceptions erstellen. Eine Exception kann ein <b>String</b>, eine <b>Nummer</b>, ein <b>Boolean</b> oder ein <b>Objekt</b> sein. In diesem Fall ist unsere Exception der String `'Hello world'`.\n\nMit dem `catch` Statement können wir definieren, was passiert, wenn die Exception im `try` Block eintritt. Wenn die Exception eintritt wird der String `'Hello world'` ausgegeben. Nun loggen wir `e`, was gleich dem String ist. Das Ergebnis ist `'Oh an error: Hello world'`."},{"id":53,"question":" Was ist der Output?","codeSnippet":"function Car() {\n  this.make = \"Lamborghini\";\n  return { make: \"Maserati\" };\n}\n\nconst myCar = new Car();\nconsole.log(myCar.make);","answerOptions":{"A":"`\"Lamborghini\"`","B":"`\"Maserati\"`","C":"`ReferenceError`","D":"`TypeError`"},"correctAnswer":"B","answerExplanation":"Wenn man eine Property ausgibt ist der Wert der Property gleich dem ausgegeben Wert und nicht dem Wert, der im Constructor definiert wurde. Wir geben den String `\"Maserati\"` aus, sodass `myCar.make` gleich `\"Maserati\"` ist."},{"id":54,"question":" Was ist der Output?","codeSnippet":"(() => {\n  let x = (y = 10);\n})();\n\nconsole.log(typeof x);\nconsole.log(typeof y);","answerOptions":{"A":"`\"undefined\", \"number\"`","B":"`\"number\", \"number\"`","C":"`\"object\", \"number\"`","D":"`\"number\", \"undefined\"`"},"correctAnswer":"A","answerExplanation":"`let x = y = 10;` ist kurz für:\n\n```javascript\ny = 10;\nlet x = y;\n```\n\nWenn wir `y` gleich `10` setzen, erstellen wir eigentlich eine Property `y` im globalen Objekt (`window` im Browser oder `global` in Node). Im Browser ist jetzt `window.y` gleich `10`.\n\nDann erstellen wir eine Variable `x` mit dem Wert von `y` (`10`). Variablen, die mit `let` erstellt werden sind _Block-Scoped_, was bedeutet, dass sie nur in dem Block existieren, wo sie erstellt wurden – der hier erstellte Funktion (IIFE) in diesem Fall. Wenn wir den `typeof` Operator nutzen ist `x` nicht definiert. Wir versuchen auf `x` außerhalb des Scopes zuzugreifen, was bedeutet, dass `x` `\"undefined\"` ist. `console.log(typeof x)` gibt daher `\"undefined\"` aus.\n\nDa wir die Variable `y` aber global erstellt haben ist ihr Wert `10` auch hier verfügbar und überall in userem Code aufrufbar. `y` ist definiert und beinhaltet einen Wert vom Typ `\"number\"`. `console.log(typeof y)` gibt daher `\"number\"` aus."},{"id":55,"question":" Was ist der Output?","codeSnippet":"class Dog {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nDog.prototype.bark = function() {\n  console.log(`Woof I am ${this.name}`);\n};\n\nconst pet = new Dog(\"Mara\");\n\npet.bark();\n\ndelete Dog.prototype.bark;\n\npet.bark();","answerOptions":{"A":"`\"Woof I am Mara\"`, `TypeError`","B":"`\"Woof I am Mara\"`,`\"Woof I am Mara\"`","C":"`\"Woof I am Mara\"`, `undefined`","D":"`TypeError`, `TypeError`"},"correctAnswer":"A","answerExplanation":"Properties von Objekten können mit dem `delete` Keyword entfernt werden, selbst am Prototype. Beim entfernen von Properties am Prototype ist zu beachten, dass diese dann aus der Prototypen-Kette verschwinden. In unserem Fall existiert die `bark` Funktion nicht mehr am Prototype nachdem `delete Dog.prototype.bark` ausgeführt wurde.\n\nWenn wir versuchen etwas auszuführen, was keine Funktion ist, wird ein `TypeError` ausgeworfen. In diesem Fall `TypeError: pet.bark is not a function`, da `pet.bark` `undefined` ist."},{"id":56,"question":" Was ist der Output?","codeSnippet":"const set = new Set([1, 1, 2, 3, 4]);\n\nconsole.log(set);","answerOptions":{"A":"`[1, 1, 2, 3, 4]`","B":"`[1, 2, 3, 4]`","C":"`{1, 1, 2, 3, 4}`","D":"`{1, 2, 3, 4}`"},"correctAnswer":"D","answerExplanation":"Das `Set` Objekt ist eine Sammlung von _eindeutigen_ Werten: jeder Wert kann nur ein Mal in einem Set vorkommen.\n\nWir übergeben `[1, 1, 2, 3, 4]` mit einer doppelten `1`. Da wir keine doppelten Werte in einem Set haben können wird eine `1` entfernt. Das Ergebnis ist `{1, 2, 3, 4}`."},{"id":57,"question":" Was ist der Output?","codeSnippet":"// counter.js\nlet counter = 10;\nexport default counter;","answerOptions":{"A":"`10`","B":"`11`","C":"`Error`","D":"`NaN`"},"correctAnswer":"C","answerExplanation":"Ein importiertes Modul ist _read-only_, was bedeutet, dass importierte Module nicht geändert werden können. Nur das Modul, welches diese exportiert kann deren Wert ändern.\n\nWenn wir also den Wert von `myCounter` erhöhen bekommen wir den Fehler `myCounter is read-only and cannot be modified`."},{"id":58,"question":" Was ist der Output?","codeSnippet":"const name = \"Lydia\";\nage = 21;\n\nconsole.log(delete name);\nconsole.log(delete age);","answerOptions":{"A":"`false`, `true`","B":"`\"Lydia\"`, `21`","C":"`true`, `true`","D":"`undefined`, `undefined`"},"correctAnswer":"A","answerExplanation":"Der `delete` Operator gibt einen Boolean Wert zurück: `true` bei erfolgreichem entfernen, oder andernfalls `false`. Variablen, die mit `var`, `let` oder `const` deklariert werden, können andererseits  nicht mit `delete` entfernt werden.\n\nDer Wert von `name` wurde mit `const` deklariert, weshalb `delete` nicht möglich ist und `false` zurückgegeben wird. Als wir `age` den Wert `21` zugewiesen haben, haben wir eine Property `age` zum globalen Objekt hinzugefügt. Diese Properties kann man mit `delete` entfernen, sodass `delete age` `true` zurückgibt."},{"id":59,"question":" Was ist der Output?","codeSnippet":"const numbers = [1, 2, 3, 4, 5];\nconst [y] = numbers;\n\nconsole.log(y);","answerOptions":{"A":"`[[1, 2, 3, 4, 5]]`","B":"`[1, 2, 3, 4, 5]`","C":"`1`","D":"`[1]`"},"correctAnswer":"C","answerExplanation":"Wir können durch Destructuring Werte aus Arrays oder Properties aus Objekten entpacken. Zum Beispiel:\n\n```javascript\n[a, b] = [1, 2];\n```\n\n<img src=\"https://i.imgur.com/ADFpVop.png\" width=\"200\">\n\nDer Wert von `a` ist jetzt `1` und der Wert von `b` ist jetzt `2`. Was wir in der Frage eigentlich getan haben ist:\n\n```javascript\n[y] = [1, 2, 3, 4, 5];\n```\n\n<img src=\"https://i.imgur.com/NzGkMNk.png\" width=\"200\">\n\nDas bedeutet, dass der Wert von `y` gleich des ersten Wertes im Array ist, sprich der Zahl `1` entspricht. Wenn wir `y` loggen bekommen wir `1` ausgegeben."},{"id":60,"question":" Was ist der Output?","codeSnippet":"const user = { name: \"Lydia\", age: 21 };\nconst admin = { admin: true, ...user };\n\nconsole.log(admin);","answerOptions":{"A":"`{ admin: true, user: { name: \"Lydia\", age: 21 } }`","B":"`{ admin: true, name: \"Lydia\", age: 21 }`","C":"`{ admin: true, user: [\"Lydia\", 21] }`","D":"`{ admin: true }`"},"correctAnswer":"B","answerExplanation":"Es ist möglich Objekte mit dem Spread Operator `...` zu verbinden. Dieser erstellt Kopien der Key/Value Paare eines Objektes und fügt diese dem anderen Objekt hinzu. In diesem Fall wird eine Kopie des `user` Objekts erstellt und dem `admin` Objekt zugewiesen. Das `admin` Objekt beinhaltet nun die kopierten Key/Value Paare, sodass das Ergebnis `{ admin: true, name: \"Lydia\", age: 21 }` ist."},{"id":61,"question":" Was ist der Output?","codeSnippet":"const person = { name: \"Lydia\" };\n\nObject.defineProperty(person, \"age\", { value: 21 });\n\nconsole.log(person);\nconsole.log(Object.keys(person));","answerOptions":{"A":"`{ name: \"Lydia\", age: 21 }`, `[\"name\", \"age\"]`","B":"`{ name: \"Lydia\", age: 21 }`, `[\"name\"]`","C":"`{ name: \"Lydia\"}`, `[\"name\", \"age\"]`","D":"`{ name: \"Lydia\"}`, `[\"age\"]`"},"correctAnswer":"B","answerExplanation":"Mit der `defineProperty` Methode können wir neue Properties zu einem Objekt hinzufügen oder bestehende modifizieren. Wenn wir mit der `defineProperty` Methode Properties einem Objekt hinzufügen, sind diese standardmäßig _nicht zählbar_. Die `Object.keys` Methode gibt alle _zählbaren_ Property Namen eines Objektes zurück, in diesem Fall nur `\"name\"`.\n\nProperties, die mit `defineProperty` erstellt wurden sind standardmäßig unveränderbar. Man kann dieses Verhalten mit den `writable`, `configurable` und `enumerable` Properties verändern. Auf diese Art gibt die `defineProperty` Methode mehr Kontrolle über die Properties, die einem Objekt hinzugefügt werden."},{"id":62,"question":" Was ist der Output?","codeSnippet":"const settings = {\n  username: \"lydiahallie\",\n  level: 19,\n  health: 90\n};\n\nconst data = JSON.stringify(settings, [\"level\", \"health\"]);\nconsole.log(data);","answerOptions":{"A":"`\"{\"level\":19, \"health\":90}\"`","B":"`\"{\"username\": \"lydiahallie\"}\"`","C":"`\"[\"level\", \"health\"]\"`","D":"`\"{\"username\": \"lydiahallie\", \"level\":19, \"health\":90}\"`"},"correctAnswer":"A","answerExplanation":"Das zweite Argument von `JSON.stringify` ist ein _Replacer_. Der Replacer kann entweder eine Funktion oder ein Array sein und gibt uns Kontrolle darüber, wie die Werte in Strings umgewandelt werden sollen.\n\nWenn der Replacer ein _Array_ ist, werden nur die Properties dem JSON String hinzugefügt, die in dem Array aufgeführt sind. In diesem Fall sind das nur `\"level\"` und `\"health\"`. `\"username\"` ist ausgeschlossen. `data` ist jetzt gleich `\"{\"level\":19, \"health\":90}\"`.\n\nWenn der Replacer eine _Funktion_ ist, so wird diese Funktion für jede Property im Objekt aufgerufen, die in Strings umgewandelt wird. Der Wert, den die Funktion zurückgibt, ist der Wert der Property, die dem JSON String hinzugefügt wird. Ist der Wert `undefined`, so wird die Property ausgeschlossen."},{"id":63,"question":" Was ist der Output?","codeSnippet":"let num = 10;\n\nconst increaseNumber = () => num++;\nconst increasePassedNumber = number => number++;\n\nconst num1 = increaseNumber();\nconst num2 = increasePassedNumber(num1);\n\nconsole.log(num1);\nconsole.log(num2);","answerOptions":{"A":"`10`, `10`","B":"`10`, `11`","C":"`11`, `11`","D":"`11`, `12`"},"correctAnswer":"A","answerExplanation":"Der unäre Operator `++` _gibt zuerst_ den Wert des Operanden aus und _erhöht danach_ den Wert des Operanden. Der Wert `num1` ist `10`, da `increaseNumber` zuerst den Wert von `num1` (`10`) ausgibt und ihn danach erhöht.\n\n`num2` ist gleich `10`, da wir `num1` `increasePassedNumber` zugewiesen haben. `number` ist gleich `10` (der Wert von `num1`). Der unäre Operator `++` gibt erneut _zuerst_ den Wert des Operanden aus und _erhöht danach_ den Wert. Der Wert von `number` ist `10`, sodass `num2` ebenfalls `10` ist."},{"id":64,"question":" Was ist der Output?","codeSnippet":"const value = { number: 10 };\n\nconst multiply = (x = { ...value }) => {\n  console.log((x.number *= 2));\n};\n\nmultiply();\nmultiply();\nmultiply(value);\nmultiply(value);","answerOptions":{"A":"`20`, `40`, `80`, `160`","B":"`20`, `40`, `20`, `40`","C":"`20`, `20`, `20`, `40`","D":"`NaN`, `NaN`, `20`, `40`"},"correctAnswer":"C","answerExplanation":"In ES6 können wir Parameter mit einem Standardwert initialisieren. Der Wert des Parameters wird als Standard gesetzt, wenn kein anderer Wert übergeben wird oder der Wert des Parameters `\"undefined\"` ist. In diesem Fall verteilen wir die Properties von `value` in einem neuen Objekt, sodass `x` den Standardwert `{ number: 10 }` bekommt.\n\nDas Standard Argument wird beim _Aufruf_ evaluiert. Jedes Mal, wenn wir die Funktion aufrufen, wird ein _neues_ Objekt erstellt. Wir rufen die `multiply` Funktion die ersten beiden Male auf ohne einen Wert zu übergeben: `x` hat daher den Standardwert `{ number: 10 }`. Wir loggen dann den multiplizierten Wert davon, sodass wir `20` bekommen.\n\nBeim dritten Mal wird die `multiply` Funktion mit einem Argument für `value` aufgerufen. Der `*=` Operator ist kurz für `x.number = x.number * 2`: wir ändern den Wert von `x.number` und loggen den multiplizierten Wert `20`.\n\nBeim vierten Mal übergeben wir wieder eine `value`. `x.number` wurde zuvor in `20` geändert, sodass `x.number *= 2` jetzt `40` loggt."},{"id":65,"question":" Was ist der Output?","codeSnippet":"[1, 2, 3, 4].reduce((x, y) => console.log(x, y));","answerOptions":{"A":"`1` `2` und `3` `3` und `6` `4`","B":"`1` `2` und `2` `3` und `3` `4`","C":"`1` `undefined` und `2` `undefined` und `3` `undefined` und `4` `undefined`","D":"`1` `2` und `undefined` `3` und `undefined` `4`"},"correctAnswer":"D","answerExplanation":"Das erste Argument, welches die `reduce` Methode erhält ist der _Akkumulator_ `x`. Das zweite Argument ist der _aktuelle Wert_, `y`. Durch die `reduce` Methode führen wir eine Callback Funktion an jedem Element des Arrays aus, was im Endeffekt einen einzelnen Wert ausgibt.\n\nIn diesem Beispiel geben wir nicht irgendwelche Werte aus, sondern loggen einfach nur den Akkumulator und den momentanen Wert.\n\nDer Wert des Akkumulators ist gleich dem vorhergehenden Wert der Callback Funktion. Wenn wir `initialValue` nicht an die `reduce` Methode übergeben bleibt der Akkumulator gleich dem ersten Element des ersten Calls.\n\nBeim ersten Call ist der Akkumulator (`x`) gleich `1` und der aktuelle Wert (`y`) ist `2`. Da wir in der Callback Funktion bleiben loggen wir den Akkumulator und den aktuellen Wert: `1` und `2`.\n\nWenn wir keinen Wert einer Funktion ausgeben wird `undefined` ausgegeben. Beim nächsten Call ist der Akkumulator daher `undefined` und der aktuelle Wert ist `3`. `undefined` und `3` werden geloggt.\n\nBeim vierten Call geben wir wieder nichts aus, sodass der Akkumulator wieder `undefined` ist und der aktuelle Wert `4`. `undefined` und `4` werden geloggt."},{"id":66,"question":" Mit welchem Constructor können wir die `Dog` Klasse erweitern?","codeSnippet":"class Dog {\n  constructor(name) {\n    this.name = name;\n  }\n};\n\nclass Labrador extends Dog {\n  // 1 \n  constructor(name, size) {\n    this.size = size;\n  }\n  // 2\n  constructor(name, size) {\n    super(name);\n    this.size = size;\n  }\n  // 3\n  constructor(size) {\n    super(name);\n    this.size = size;\n  }\n  // 4 \n  constructor(name, size) {\n    this.name = name;\n    this.size = size;\n  }\n\n};","answerOptions":{"A":"1","B":"2","C":"3","D":"4"},"correctAnswer":"B","answerExplanation":"In einer abgeleiteten Klasse kann das `this` Keyword nicht aufgerufen werden, bevor `super` aufgerufen wurde. Wenn man das versucht wird ein ReferenceError ausgeworfen: 1 und 4 würden daher einen Referenz-Fehler ausgeben.\n\nMit dem `super` Keyword können wir den Constructor der Elternklasse mit gegebenen Argumenten aufrufen. Der Constructor der Elternklasse erhält das `name` Argument, sodass wir `name` an `super` übergeben müssen.\n\nDie `Dog` Klasse erhält zwei Argumente, `name` da es `Animal` erweitert und `size` als extra Property der `Dog` Klasse. Beide müssen an die Constructor Funktion von `Dog` übergeben werden, was nur bei Constructor 2 richtig ist."},{"id":67,"question":" Mit welchem Constructor können wir die `Dog` Klasse erweitern?","codeSnippet":"// index.js\nconsole.log('running index.js);\nimport { sum } from './sum.js';\nconsole.log(sum(1, 2));\n\n// sum.js\nconsole.log('running sum.js');\nexport const sum = (a, b) => a + b;","answerOptions":{"A":"`running index.js`, `running sum.js`, `3`","B":"`running sum.js`, `running index.js`, `3`","C":"`running sum.js`, `3`, `running index.js`","D":"`running index.js`, `undefined`, `running sum.js`"},"correctAnswer":"B","answerExplanation":"Mit dem `import` Keyword werden alle importierten Module _vorgeparsed_. Das bedeutet, dass importierte Module _zuerst_ ausgeführt werden, der Code in der eigentlichen Datei wird _danach_ ausgeführt.\n\nDas ist der große Unterschied zwischen `require()` in CommonJS und `import`. Mit `require()` können Dependencies bei Bedarf geladen werden, während der Code ausgeführt wird. Hätten wir `require()` anstelle von `import` verwendet, wäre `running index.js`, `running sum.js`, `3` in der Konsole geloggt worden."},{"id":68,"question":" Was ist der Output?","codeSnippet":"console.log(Number(2) === Number(2))\nconsole.log(Boolean(false) === Boolean(false))\nconsole.log(Symbol('foo') === Symbol('foo'))","answerOptions":{"A":"`true`, `true`, `false`","B":"`false`, `true`, `false`","C":"`true`, `false`, `true`","D":"`true`, `true`, `true`"},"correctAnswer":"A","answerExplanation":"Jedes Symbol ist eindeutig. Der Sinn des Argumentes, welches an das Symbol weitergegeben wird, ist dem Symbol eine Beschreibung zu geben. Der Wert des Symbols hängt nicht von diesem Argument ab. Beim vergleichen der Symbole werden zwei komplett neue Symbole erstellt: das erste `Symbol('foo')` und das zweite `Symbol('foo')`. Diese beiden Werte sind eindeutig und nicht identisch, weshalb `Symbol('foo') === Symbol('foo')` `false` ausgibt."},{"id":69,"question":" Was ist der Output?","codeSnippet":"const name = \"Lydia Hallie\"\nconsole.log(name.padStart(13))\nconsole.log(name.padStart(2))","answerOptions":{"A":"`\"Lydia Hallie\"`, `\"Lydia Hallie\"`","B":"`\"           Lydia Hallie\"`, `\"  Lydia Hallie\"` (`\"[13x whitespace]Lydia Hallie\"`, `\"[2x whitespace]Lydia Hallie\"`)","C":"`\" Lydia Hallie\"`, `\"Lydia Hallie\"` (`\"[1x whitespace]Lydia Hallie\"`, `\"Lydia Hallie\"`)","D":"`\"Lydia Hallie\"`, `\"Lyd\"`,"},"correctAnswer":"C","answerExplanation":"Mit der `padStart` Methode können wir Padding am Anfang des Strings hinzufügen. Der Wert, der an die Methode übergeben wird ist die _absolute_ Länge des Strings mit dem Padding. Der String `\"Lydia Hallie\"` hat eine Länge von `12`. `name.padStart(13)` fügt ein Leerzeichen am Anfang des Strings ein, weil 12 + 1 = 13 ist.\n\nFalls der Wert, der an `padStart` übergeben wurde kleiner ist, als die Länge des Arrays, so wird kein Padding hinzugefügt."},{"id":70,"question":" Was ist der Output?","codeSnippet":"console.log(\"🥑\" + \"💻\");","answerOptions":{"A":"`\"🥑💻\"`","B":"`257548`","C":"Ein String, der den Emoji Code beinhaltet","D":"Error"},"correctAnswer":"A","answerExplanation":"Mit dem `+` Operator können Strings zusammengesetzt werden. In diesem Fall werden die Strings `\"🥑\"` und `\"💻\"` zusammengesetzt, was `\"🥑💻\"` ergibt."},{"id":71,"question":" Wie können wir die Werte loggen, die nach dem `console.log` auskommentiert wurden?","codeSnippet":"function* startGame() {\n  const Antwort = yield \"Do you love JavaScript?\";\n  if (Antwort !== \"Yes\") {\n    return \"Oh wow... Guess we're gone here\";\n  }\n  return \"JavaScript loves you back ❤️\";\n}\n\nconst game = startGame();\nconsole.log(/* 1 */); // Do you love JavaScript?\nconsole.log(/* 2 */); // JavaScript loves you back ❤️","answerOptions":{"A":"`game.next(\"Yes\").value` und `game.next().value`","B":"`game.next.value(\"Yes\")` und `game.next.value()`","C":"`game.next().value` und `game.next(\"Yes\").value`","D":"`game.next.value()` und `game.next.value(\"Yes\")`"},"correctAnswer":"C","answerExplanation":"Eine Generator Funktion pausiert die Ausführung, wenn das `yield` Keyword vorliegt. Zuerst müssen wir den String \"Do you love JavaScript?\" abwarten, was mit `game.next().value` möglich ist.\n\nJede Zeile wird ausgeführt, bis das erste `yield` Keyword auftritt. Da auf der ersten Zeile ein `yield` in der Funktion vorliegt wird die Ausführung damit angehalten. Das bedeutet, dass die Variable `Antwort` _noch nicht definiert_ wurde.\n\nWenn wir `game.next(\"Yes\").value` aufrufen wird das vorhergehende `yield` durch den Wert des Parameters ersetzt, der an `next()` übergeben wird - `\"Yes\"` in diesem Fall. Der Wert der Variable `Antwort` ist jetzt gleich `\"Yes\"`. Das if-Statement gibt `false` aus und `JavaScript loves you back ❤️` wird geloggt."},{"id":72,"question":" Was ist der Output?","codeSnippet":"console.log(String.raw`Hello\\nworld`);","answerOptions":{"A":"`Hello world!`","B":"`Hello` <br />&nbsp; &nbsp; &nbsp;`world`","C":"`Hello\\nworld`","D":"`Hello\\n` <br /> &nbsp; &nbsp; &nbsp;`world`"},"correctAnswer":"C","answerExplanation":"`String.raw` gibt einen String aus, in dem die Escapes (`\\n`, `\\v`, `\\t` etc.) ignoriert werden! Backslashes sind problematisch, weil man mit sowas in der Art rechnen muss:\n\n`` const path = `C:\\Documents\\Projects\\table.html` ``\n\nDas würde dann wiefolgt gerendert werden:\n\n`\"C:DocumentsProjects able.html\"`\n\nMit `String.raw` werden diese ignoriert und das Ergebnis ist:\n\n`C:\\Documents\\Projects\\table.html`\n\nIn unserem Fall ist das Ergebnis `Hello\\nworld`, was geloggt wird."},{"id":73,"question":" Was ist der Output?","codeSnippet":"async function getData() {\n  return await Promise.resolve(\"I made it!\");\n}\n\nconst data = getData();\nconsole.log(data);","answerOptions":{"A":"`\"I made it!\"`","B":"`Promise {<resolved>: \"I made it!\"}`","C":"`Promise {<pending>}`","D":"`undefined`"},"correctAnswer":"C","answerExplanation":"Eine `async` Funktion gibt immer ein Promise zurück. Mit `await` wird das Ergebnis des Promises abgewartet und ein ausstehendes Promise wird ausgegeben, wenn wir `getData()` aufrufen um `data` gleich zu setzen.\n\nWenn wir auf den finalen Wert `\"I made it\"` zugreifen wollen, nutzen wir die `.then()` Methode an `data`:\n\n`data.then(res => console.log(res))`\n\nDas hätte `\"I made it!\"` ausgegeben."},{"id":74,"question":" Was ist der Output?","codeSnippet":"function addToList(item, list) {\n  return list.push(item);\n}\n\nconst result = addToList(\"apple\", [\"banana\"]);\nconsole.log(result);","answerOptions":{"A":"`['apple', 'banana']`","B":"`2`","C":"`true`","D":"`undefined`"},"correctAnswer":"B","answerExplanation":"Die `.push()` Methode gibt die _Länge_ des Arrays aus! Das Array beinhaltete zuerst ein einziges Element (`\"banana\"`) und hatte eine Länge von `1`. Nachdem wir `\"apple\"` hinzugefügt haben beinhaltet das Array zwei Elemente und hat eine Länge von `2`. Das wird letztlich von der `addToList` Funktion ausgegeben.\n\nDie `push` Methode verändert das ursprüngliche Array. Wenn wir das _Array_ der Funktion anstelle der _Länge des Arrays_ ausgeben möchten, hätten wir `list` ausgeben müssen."},{"id":75,"question":" Was ist der Output?","codeSnippet":"const box = { x: 10, y: 20 };\n\nObject.freeze(box);\n\nconst shape = box;\nshape.x = 100;\n\nconsole.log(shape);","answerOptions":{"A":"`{ x: 100, y: 20 }`","B":"`{ x: 10, y: 20 }`","C":"`{ x: 100 }`","D":"`ReferenceError`"},"correctAnswer":"B","answerExplanation":"`Object.freeze` macht es unmöglich das Objekt zu verändern (hinzufügen, entfernen, verändern), es sei denn der Wert ist ein weiteres Objekt.\n\nWenn wir die Variable `shape` erstellen und gleich dem eingefrorenen Objekt `box` setzen, ist `shape` ebenso eingefroren. Man kann mit `Object.isFrozen` prüfen, ob ein Objekt eingefroren ist.\nIn unserem Fall gibt `Object.isFrozen(shape)` `true` zurück, da die Variable `shape` eine Referenz zu einem eingefrorenen Objekt ist.\n\nDa `shape` eingefroren ist und der Wert von `x` kein Objekt ist, können wir den Wert von `x` nicht verändern. `x` ist immernoch gleich `10` und `{ x: 10, y: 20 }` wird geloggt."},{"id":76,"question":" Was ist der Output?","codeSnippet":"const { name: myName } = { name: \"Lydia\" };\n\nconsole.log(name);","answerOptions":{"A":"`\"Lydia\"`","B":"`\"myName\"`","C":"`undefined`","D":"`ReferenceError`"},"correctAnswer":"D","answerExplanation":"Wenn wir die Property `name` aus dem Objekt auf der rechten Seite destructuren, weisen wir den Wert einer neuen Variable `myName` zu.\n\nMit `{ name: myName }` sagen wir JavaScript, dass wir eine neue Variable mit dem Namen `myName` erstellen möchten und den Wert von `name` zuweisen.\n\nDa `name` nicht definiert ist, wird ein ReferenceError ausgeworfen."},{"id":77,"question":" Is this a pure function?","codeSnippet":"function sum(a, b) {\n  return a + b;\n}","answerOptions":{"A":"Ja","B":"Nein"},"correctAnswer":"A","answerExplanation":"Eine pure Funktion ist eine Funktion, die _immer_ das gleiche Ergebnis zurück gibt, wenn die gleichen Argumente eingegeben werden.\n\nDie `sum` Funktion gibt daher immer das gleiche Ergebnis aus. Wenn wir `1` und `2` eingeben wird _immer_ `3` ausgegeben. Wenn wir `5` und `10` eingeben wird _immer_ `15` ausgegeben usw. Das ist die Definition einer puren Funktion."},{"id":78,"question":" Was ist der Output?","codeSnippet":"const add = () => {\n  const cache = {};\n  return num => {\n    if (num in cache) {\n      return `From cache! ${cache[num]}`;\n    } else {\n      const result = num + 10;\n      cache[num] = result;\n      return `Calculated! ${result}`;\n    }\n  };\n};\n\nconst addFunction = add();\nconsole.log(addFunction(10));\nconsole.log(addFunction(10));\nconsole.log(addFunction(5 * 2));","answerOptions":{"A":"`Calculated! 20` `Calculated! 20` `Calculated! 20`","B":"`Calculated! 20` `From cache! 20` `Calculated! 20`","C":"`Calculated! 20` `From cache! 20` `From cache! 20`","D":"`Calculated! 20` `From cache! 20` `Error`"},"correctAnswer":"C","answerExplanation":"Die `add` Funktion ist _memoized_. Mit Memoization können wir Ergebnisse einer Funktion cachen, um die Performance zu beschleunigen. In diesem Fall erstellen wir ein `cache` Objekt, welches die zuvor ausgegebenen Werte speichert.\n\nWenn wir die `addFunction` Funktion erneut mit den gleichen Argumenten aufrufen wird zuerst geprüft, ob der Wert bereits im Cache vorhanden sind. Ist das der Fall, so wird der Cache diesen Wert ausgeben und damit Ausführzeit sparen. Wenn der Wert nicht gecached ist wird der neue Wert berechnet und danach im Cache gespeichert.\n\nWir rufen die `addFunction` Funktion drei mal mit dem gleichen Wert auf: bei der ersten Ausführung. ist der Wert der Funktion `10` nicht im Cache. Die Kondition des if-Statements `num in cache` gibt `false` aus und der else Block wird ausgeführt: `Calculated! 20` wird geloggt und der Wert des Ergebnisses wird dem Cache Objekt hinzugefügt. `cache` sieht jetzt wiefolgt aus: `{ 10: 20 }`.\n\nBei der zweiten Ausführung beinhaltet das `cache` Objekt den Wert `10`. Die Kondition des if-Statements `num in cache` gibt `true` aus und `'From cache! 20'` wird geloggt.\n\nBeim dritten Mal geben wir `5 * 2` als Argument in die Funktion ein, was `10` ergibt. Das `cache` Objekt beinhaltet den Wert `10` und das if-Statement `num in cache` gibt wieder `true` aus und `'From cache! 20'` wird geloggt."},{"id":79,"question":" Was ist der Output?","codeSnippet":"const myLifeSummedUp = [\"☕\", \"💻\", \"🍷\", \"🍫\"]\n\nfor (let item in myLifeSummedUp) {\n  console.log(item)\n}\n\nfor (let item of myLifeSummedUp) {\n  console.log(item)\n}","answerOptions":{"A":"`0` `1` `2` `3` und `\"☕\"` ` \"💻\"` `\"🍷\"` `\"🍫\"`","B":"`\"☕\"` ` \"💻\"` `\"🍷\"` `\"🍫\"` und `\"☕\"` ` \"💻\"` `\"🍷\"` `\"🍫\"`","C":"`\"☕\"` ` \"💻\"` `\"🍷\"` `\"🍫\"` und `0` `1` `2` `3`","D":"`0` `1` `2` `3` und `{0: \"☕\", 1: \"💻\", 2: \"🍷\", 3: \"🍫\"}`"},"correctAnswer":"A","answerExplanation":"Mit einer _for-in_ Schleife können wir über **zählbare** Properties iterieren. In einem Array sind die zählbaren Properties die \"Keys\" des Array Elements, sprich deren Indexe. Ein Array könnte man also wiefolgt sehen:\n\n`{0: \"☕\", 1: \"💻\", 2: \"🍷\", 3: \"🍫\"}`\n\nDaher werden die zählbaren Properties `0` `1` `2` `3` geloggt.\n\nMit einer _for-of_ Schleife können wir über **wiederholbare** Elemente iterieren. Ein Array ist wiederholbar. Wenn wir also über das Array iterieren, ist die Variable \"item\" gleich dem Element, welches momentan iteriert wird: `\"☕\"` ` \"💻\"` `\"🍷\"` `\"🍫\"` wird geloggt."},{"id":80,"question":" Was ist der Output?","codeSnippet":"const list = [1 + 2, 1 * 2, 1 / 2]\nconsole.log(list)","answerOptions":{"A":"`[\"1 + 2\", \"1 * 2\", \"1 / 2\"]`","B":"`[\"12\", 2, 0.5]`","C":"`[3, 2, 0.5]`","D":"`[1, 1, 1]`"},"correctAnswer":"C","answerExplanation":"Array Elemente können jeden Wert halten: Nummern, Strings, Objekte, andere Arrays, null, Booleans, undefined und andere Expressions wie Funktionen, Berechnungen oder ein Datum.\n\nDas Element ist gleich dem ausgegebenen Wert. `1 + 2` ergibt `3`, `1 * 2` ergibt `2`, und `1 / 2` ergibt `0.5`."},{"id":81,"question":" Was ist der Output?","codeSnippet":"function sayHi(name) {\n  return `Hi there, ${name}`\n}\n\nconsole.log(sayHi())","answerOptions":{"A":"`Hi there, `","B":"`Hi there, undefined`","C":"`Hi there, null`","D":"`ReferenceError`"},"correctAnswer":"B","answerExplanation":"Standardmäßig haben Argumente den Wert `undefined`, es sei denn der Funktion wurde ein Wert zugewiesen. In diesem Fall haben wir dem `name` Argument keinen Wert zugewiesen, weshalb `name` `undefined` ist.\n\nIn ES6 können wir diesen Standardwert `undefined` mit Standard Parametern überschreiben, zum Beispiel:\n\n`function sayHi(name = \"Lydia\") { ... }`\n\nIn diesem Fall, falls wir kein Argument oder `undefined` eingeben ist `name` immer `Lydia`."},{"id":82,"question":" Was ist der Output?","codeSnippet":"var status = \"😎\"\n\nsetTimeout(() => {\n  const status = \"😍\"\n\n  const data = {\n    status: \"🥑\",\n    getStatus() {\n      return this.status\n    }\n  }\n\n  console.log(data.getStatus())\n  console.log(data.getStatus.call(this))\n}, 0)","answerOptions":{"A":"`\"🥑\"` und `\"😍\"`","B":"`\"🥑\"` und `\"😎\"`","C":"`\"😍\"` und `\"😎\"`","D":"`\"😎\"` und `\"😎\"`"},"correctAnswer":"B","answerExplanation":"Der Wert des `this` Keywords hängt davon ab, wo es verwendet wird. In einer **Methode**, wie `getStatus` bezieht sich das `this` Keyword auf das _Objekt, zu dem die Methode gehört_. Die Methode gehört zum `data` Objekt, sodass `this` sich auf das `data` Objekt bezieht. Wenn wir `this.status` loggen wird die `status` Property des `data` Objekts geloggt, was `\"🥑\"` ist.\n\nMit der `call` Methode können wir das Objekt, auf welches sich das `this` Keyword bezieht ändern. In **Funktionen** bezieht sich `this` auf das _Objekt, zu dem die Funktion gehört_. Wir erklären die `setTimeout` Funktion im _globalen Objekt_, sodass sich `this` in `setTimeout` auf das _globale Objekt_ bezieht. Im globalen Objekt gibt es _status_ mit dem Wert `\"😎\"`, was geloggt wird."},{"id":83,"question":" Was ist der Output?","codeSnippet":"const person = {\n  name: \"Lydia\",\n  age: 21\n}\n\nlet city = person.city\ncity = \"Amsterdam\"\n\nconsole.log(person)","answerOptions":{"A":"`{ name: \"Lydia\", age: 21 }`","B":"`{ name: \"Lydia\", age: 21, city: \"Amsterdam\" }`","C":"`{ name: \"Lydia\", age: 21, city: undefined }`","D":"`\"Amsterdam\"`"},"correctAnswer":"A","answerExplanation":"Wir setzen die Variable `city` gleich dem Wert der Property `city` am `person` Objekt. Da am `person` Objekt keine Property namens `city` existiert wird der Wert gleich `undefined` gesetzt.\n\nDa wir _nicht_ das `person` Objekt selbst referenzieren, sondern einfach die Variable `city` gleich dem aktuellen Wert von `city` am `person` Objekt setzen bleibt dieses `undefined`.\n\nDann setzen wir `city` gleich dem String `\"Amsterdam\"`. Das verändert aber nicht das `person` Objekt, da es keine Referenz dazu am Objekt gibt.\n\nWenn wir `person` loggen bekommen wir daher das unveränderte Objekt angezeigt."},{"id":84,"question":" Was ist der Output?","codeSnippet":"function checkAge(age) {\n  if (age < 18) {\n    const message = \"Sorry, you're too young.\"\n  } else {\n    const message = \"Yay! You're old enough!\"\n  }\n\n  return message\n}\n\nconsole.log(checkAge(21))","answerOptions":{"A":"`\"Sorry, you're too young.\"`","B":"`\"Yay! You're old enough!\"`","C":"`ReferenceError`","D":"`undefined`"},"correctAnswer":"C","answerExplanation":"Variablen mit dem `const` und `let` Keyword sind _block-scoped_. Ein Block ist alles zwischen geschweiften Klammern (`{ }`), in diesem Fall die geschweiften Klammern des if/else Statements. Es ist nicht möglich eine solche Variable außerhalb des Blocks in dem sie erklärt wurde aufzurufen, daher wird ein ReferenceError ausgegeben."},{"id":85,"question":" Welche Information wird geloggt?","codeSnippet":"fetch('https://www.website.com/api/user/1')\n  .then(res => res.json())\n  .then(res => console.log(res))","answerOptions":{"A":"Das Ergebnis der `fetch` Methode.","B":"Das Ergebnis des zweiten Aufrufs der `fetch` Methode.","C":"Das Ergebnis des Callbacks im vorhergehenden `.then()`.","D":"Immer `undefined`."},"correctAnswer":"C","answerExplanation":"Der Wert von `res` im zweiten `.then` ist gleich dem ausgegebenen Wert des vorhergehenden `.then`. Man kann soviele `.then`s aneinander reihen, wie man möchte und der Wert wird immer an den nächsten Handler übergeben."},{"id":86,"question":" Wie können wir `hasName` gleich `true` setzen, vorausgesetzt wir können `true` nicht als Argument übergeben?","codeSnippet":"function getName(name) {\n  const hasName = //\n}","answerOptions":{"A":"`!!name`","B":"`name`","C":"`new Boolean(name)`","D":"`name.length`"},"correctAnswer":"A","answerExplanation":"Mit `!!name` können wir feststellen, ob `name` truthy oder falsey ist. Ist `name` truthy, so würde `!name` `false` ausgeben. `!false` (das Gleiche wie `!!name`) ergibt `true`.\n\nWenn wir `hasName` gleich `name` setzen, so beinhaltet `hasName` den Wert von `name`, nicht den Boolean Wert `true`.\n\n`new Boolean(true)` gibt einen Objekt Wrapper aus, nicht ein Boolean ansich.\n\n`name.length` gibt die Länge des Arguments aus, nicht den Boolean Wert."},{"id":87,"question":" Was ist der Output?","codeSnippet":"console.log(\"I want pizza\"[0])","answerOptions":{"A":"`\"\"\"`","B":"`\"I\"`","C":"`SyntaxError`","D":"`undefined`"},"correctAnswer":"B","answerExplanation":"Um ein Zeichen an einer bestimmten Stelle eines Strings zu bekommen kann man Bracket Notation verwenden. Das erste Zeichen in einem String hat den Index 0, usw. In diesem Fall möchten wir das Zeichen mit dem Index 0, was das Zeichen `\"I\"` loggt.\n\nDiese Methode funktioniert nicht in IE7 und davor. Hier muss `.charAt()` verwendet werden."},{"id":88,"question":" Was ist der Output?","codeSnippet":"function sum(num1, num2 = num1) {\n  console.log(num1 + num2)\n}\n\nsum(10)","answerOptions":{"A":"`NaN`","B":"`20`","C":"`ReferenceError`","D":"`undefined`"},"correctAnswer":"B","answerExplanation":"Man kann den Wert eines Standard Parameters gleich einem anderen Parameter in der Funktion setzen, sofern diese _vor_ dem Standard Parameter definiert wurden. Wir übergeben den Wert `10` an die `sum` Funktion. Wenn die `sum` Funktion nur ein Argument übergeben bekommt bedeutet das, dass der Wert für `num2` nicht gesetzt wurde und der Wert von `num1` ist gleich dem Wert `10`. Der Standardwert von `num2` ist gleich dem Wert von `num1`, sprich `10`. `num1 + num2` gibt `20` aus.\n\nWenn man den Wert des Standard Paramenters gleich dem Parameter setztm der _danach_ definiert wurde, bekommen wir einen Fehler ausgegeben, da der Wert noch nicht initialisiert wurde."},{"id":89,"question":" Was ist der Output?","codeSnippet":"// module.js \nexport default () => \"Hello world\"\nexport const name = \"Lydia\"\n\n// index.js \nimport * as data from \"./module\"\n\nconsole.log(data)","answerOptions":{"A":"`{ default: function default(), name: \"Lydia\" }`","B":"`{ default: function default() }`","C":"`{ default: \"Hello world\", name: \"Lydia\" }`","D":"Globales Objekt von `module.js`"},"correctAnswer":"A","answerExplanation":"Mit `import * as name` importieren wir _alle Exporte_ der `module.js` in `index.js` als `data`. In der Datei `module.js` haben wir zwei Exporte: den Standard Export und einen benannten Export. Der Standard Export ist eine Funktion, die `\"Hello World\"` ausgibt und der benannte Export ist eine Variable namens `name` mit dem Wert `\"Lydia\"`.\n\nDas `data` Objekt hat eine Standard Property für alle Standard Exporte, andere Properties haben die Namen des benannten Exports und der entsprechenden Werte."},{"id":90,"question":" Was ist der Output?","codeSnippet":"class Person {\n  constructor(name) {\n    this.name = name\n  }\n}\n\nconst member = new Person(\"John\")\nconsole.log(typeof member)","answerOptions":{"A":"`\"class\"`","B":"`\"function\"`","C":"`\"object\"`","D":"`\"string\"`"},"correctAnswer":"C","answerExplanation":"Klassen sind syntaktischer Zucker für Funktionskontruktoren. Das Equivalent der `Person` Klasse als Funktionskonstruktor wäre:\n\n```javascript\nfunction Person() {\n  this.name = name\n}\n```\n\nDas Aufrufen eines Funktionskonstruktors mit `new` hat zur Folge, dass eine Instanz von `Person` erstellt wird. `typeof` gibt `\"object\"` für die instanz aus. `typeof member` gibt `\"object\"` aus."},{"id":91,"question":" Was ist der Output?","codeSnippet":"let newList = [1, 2, 3].push(4)\n\nconsole.log(newList.push(5))","answerOptions":{"A":"`[1, 2, 3, 4, 5]`","B":"`[1, 2, 3, 5]`","C":"`[1, 2, 3, 4]`","D":"`Error`"},"correctAnswer":"D","answerExplanation":"Die `.push` Methode gibt die _neue Länge_ des Arrays aus, nicht die Länge des Arrays selbst. Wenn wir `newList` gleich `[1, 2, 3].push(4)` setzen, setzen wir `newList` auch gleich der Länge des Arrays: `4`.\n\nDann versuchen wir die `.push` Methode auf `newList` anzuwenden. Da `newList` den numerischen Wert `4` beinhaltet können wir die `.push` Methode nicht anwenden: ein TypeError wird ausgegeben."},{"id":92,"question":" Was ist der Output?","codeSnippet":"function giveLydiaPizza() {\n  return \"Here is pizza!\"\n}\n\nconst giveLydiaChocolate = () => \"Here's chocolate... now go hit the gym already.\"\n\nconsole.log(giveLydiaPizza.prototype)\nconsole.log(giveLydiaChocolate.prototype)","answerOptions":{"A":"`{ constructor: ...}` `{ constructor: ...}`","B":"`{}` `{ constructor: ...}`","C":"`{ constructor: ...}` `{}`","D":"`{ constructor: ...}` `undefined`"},"correctAnswer":"D","answerExplanation":"Reguläre Funktionen wie `giveLydiaPizza` haben eine `prototype` Property, die ein Objekt (Prototype Object) mit einem `constructor` ist. Arrow Funktionen dagegen (wie `giveLydiaChocolate`) haben keinen `prototype`. `undefined` wird ausgegeben, wenn wir versuchen den `prototype` mit `giveLydiaChocolate.prototype` aufzurufen."},{"id":93,"question":" Was ist der Output?","codeSnippet":"const person = {\n  name: \"Lydia\",\n  age: 21\n}\n\nfor (const [x, y] of Object.entries(person)) {\n  console.log(x, y)\n}","answerOptions":{"A":"`name` `Lydia` und `age` `21`","B":"`[\"name\", \"Lydia\"]` und `[\"age\", 21]`","C":"`[\"name\", \"age\"]` und `undefined`","D":"`Error`"},"correctAnswer":"A","answerExplanation":"`Object.entries(person)` gibt ein Array mit verschachtelten Arrays der Keys aus:\n\n`[ [ 'name', 'Lydia' ], [ 'age', 21 ] ]` \n\nMit der `for-of` Schleife iterieren wir über jedes Element in dem Array, in diesem Fall die verschachtelten Arrays. Wir können die verschachtelten Arrays mit `const [x, y]` in der for-of Schleife destrukturieren. `x` ist gleich dem ersten Element, `y` ist gleich dem zweiten Element in dem verschachtelten Array.\n\nDas erste verschachtelte Array ist `[ \"name\", \"Lydia\" ]`. `x` ist gleich `\"name\"` und `y` gleich `\"Lydia\"`, was geloggt wird.\nDas zweite verschachtelte Array ist `[ \"age\", 21 ]`. `x` ist gleich `\"age\"` und `y` ist gleich `21`, was geloggt wird."},{"id":94,"question":" Was ist der Output?","codeSnippet":"function getItems(fruitList, ...args, favoriteFruit) {\n  return [...fruitList, ...args, favoriteFruit]\n}\n\ngetItems([\"banana\", \"apple\"], \"pear\", \"orange\")","answerOptions":{"A":"`[\"banana\", \"apple\", \"pear\", \"orange\"]`","B":"`[[\"banana\", \"apple\"], \"pear\", \"orange\"]`","C":"`[\"banana\", \"apple\", [\"pear\"], \"orange\"]`","D":"`SyntaxError`"},"correctAnswer":"D","answerExplanation":"`...args` ist ein Rest-Parameter. Der Wert des Rest-Parameters ist ein Array mit allen weiteren Argumenten **und kann nur der letzte Parameter sein**! In diesem Beispiel war der Rest-Parameter das zweite Argument, was nicht möglich ist und daher einen Syntax Error ausgibt.\n\n```javascript\nfunction getItems(fruitList, favoriteFruit, ...args) {\n  return [...fruitList, ...args, favoriteFruit]\n}\n\ngetItems([\"banana\", \"apple\"], \"pear\", \"orange\")\n```\n\nDieses Beispiel würde funktionieren und `[ 'banana', 'apple', 'orange', 'pear' ]` ausgeben."},{"id":95,"question":" Was ist der Output?","codeSnippet":"function nums(a, b) {\n  if\n  (a > b)\n  console.log('a is bigger')\n  else \n  console.log('b is bigger')\n  return \n  a + b\n}\n\nconsole.log(nums(4, 2))\nconsole.log(nums(1, 2))","answerOptions":{"A":"`a is bigger`, `6` und `b is bigger`, `3`","B":"`a is bigger`, `undefined` und `b is bigger`, `undefined`","C":"`undefined` und `undefined`","D":"`SyntaxError`"},"correctAnswer":"B","answerExplanation":"In JavaScript muss das Semikolon _nicht_ explizit gesetzt werden, allerdings setzt die JavaScript Engine Semikolons nach Statements. Diesen Vorgang nennt man **automatische Semikolonsetzung**. Ein Statement ist zum Beispiel eine Variable oder ein Keyword wie `throw`, `return`, `break`, usw.\n\nIn unserem Beispiel haben wir ein `return` Statement gefolgt von einem anderen Wert `a + b` auf der _nächsten Zeile_. Da es eine neue Zeile ist, weiß JavaScript nicht, dass das der Wert ist, den wir eigentlich ausgeben wollten. Stattdessen wird automatisch ein Semikolon nach `return` gesetzt, was man wiefolgt lesen kann:\n\n```javascript\n  return;\n  a + b\n```\n\nDas bedeutet, dass `a + b` nie erreicht wird, da die Funktion auf der Zeile davor mit dem `return` Keyword endet. Wenn wie hier kein Wert ausgegeben wird, gibt die Funktion `undefined` aus.\nBedenke: Semikolons werden **nicht** automatisch nach `if/else` Statements gesetzt!"},{"id":96,"question":" Was ist der Output?","codeSnippet":"class Person {\n  constructor() {\n    this.name = \"Lydia\"\n  }\n}\n\nPerson = class AnotherPerson {\n  constructor() {\n    this.name = \"Sarah\"\n  }\n}\n\nconst member = new Person()\nconsole.log(member.name)","answerOptions":{"A":"`\"Lydia\"`","B":"`\"Sarah\"`","C":"`Error: cannot redeclare Person`","D":"`SyntaxError`"},"correctAnswer":"B","answerExplanation":"Wir können Klassen gleich anderen Klassen oder Funktions Konstruktoren setzen. In diesem Beispiel setzen wir `Person` gleich `AnotherPerson`. Der Name in diesem Konstruktor ist `Sarah`, sodass die name-Property der neuen `Person` Instanz `member` gleich `\"Sarah\"` ist."},{"id":97,"question":" Was ist der Output?","codeSnippet":"const info = {\n  [Symbol('a')]: 'b'\n}\n\nconsole.log(info)\nconsole.log(Object.keys(info))","answerOptions":{"A":"`{Symbol('a'): 'b'}` und `[\"{Symbol('a')\"]`","B":"`{}` und `[]`","C":"`{ a: \"b\" }` und `[\"a\"]`","D":"`{Symbol('a'): 'b'}` und `[]`"},"correctAnswer":"D","answerExplanation":"Ein Symbol ist nicht _zählbar_. Die `Object.keys` Methode gibt alle zählbaren Key Properties eines Objekts aus. Das Symbol ist nicht sichtbar, sodass ein leeres Array ausgegeben wird. Wenn wir das gesamte Objekt loggen sind alle Properties sichtbar, auch nicht zählbare.\n\nDas ist einer der vielen Vorteile eines Symbols: nebem einem einzigartigen Wert (welcher verhindert, dass versehentlich zwei Objekte gleiche Namen haben, zum Beispiel wenn wir mit verschiedenen Libraries arbeiten) können Properties von Objekten auf diese Art versteckt werden.\nBedenke: Man kann die Symbole dennoch mit der `Object.getOwnPropertySymbols()` Methode einsehen."},{"id":98,"question":" Was ist der Output?","codeSnippet":"const getList = ([x, ...y]) => [x, y]\nconst getUser = user => { name: user.name, age: user.age }\n\nconst list = [1, 2, 3, 4]\nconst user = { name: \"Lydia\", age: 21 }\n\nconsole.log(getList(list))\nconsole.log(getUser(user))","answerOptions":{"A":"`[1, [2, 3, 4]]` und `undefined`","B":"`[1, [2, 3, 4]]` und `{ name: \"Lydia\", age: 21 }`","C":"`[1, 2, 3, 4]` und `{ name: \"Lydia\", age: 21 }`","D":"`Error` und `{ name: \"Lydia\", age: 21 }`"},"correctAnswer":"A","answerExplanation":"Die `getList` Funktion bekommt ein Array als Argument zugewiesen. Zwischen den Klammern der `getList` Funktion wird das Array direkt destrukturiert. Man könnte das auch wiefolgt sehen:\n\n `[x, ...y] = [1, 2, 3, 4]`\n\nMit dem Rest Parameter `...y` packen wir alle übrigen Argumente in ein Array. Die übrigen Argumente sind in dem Fall `2`, `3` und `4`. Der Wert von `y` ist ein Array mit den restlichen Parametern. Der Wert von `x` ist gleich `1` sodass `[1, [2, 3, 4]]` geloggt wird.\n\nDie `getUser` Funktion bekommt ein Objekt zugewiesen. Bei Arrow Funktionen müssen wir keine geschweiften Klammern verwenden, wenn wir nur einen Wert ausgeben. Wenn wir aber ein _Objekt_ von einer Arrow Funktion ausgeben lassen möchten, so muss dieses zwischen Klammern stehen, ansonsten wird nichts ausgegeben. Die folgende Funktion hätte ein Objekt ausgegeben:\n\n```const getUser = user => ({ name: user.name, age: user.age })```\n\nDa kein Wert ausgegeben wird, gibt die Funktion `undefined` aus."},{"id":99,"question":" Was ist der Output?","codeSnippet":"const name = \"Lydia\"\n\nconsole.log(name())","answerOptions":{"A":"`SyntaxError`","B":"`ReferenceError`","C":"`TypeError`","D":"`undefined`"},"correctAnswer":"C","answerExplanation":"Die Variable `name` beinhaltet einen String, welcher logischer Weise keine Funktion ist und daher nicht ausgeführt werden kann.\n\nTypeErrors werden ausgeworfen, wenn ein Wert einen falschen Typ aufweist. JavaScript hat eine Funktion erwartet, da wir `name` ausführen. Da es aber ein String war bekommen wir den TypeError: name is not a function!\n\nSyntaxErrors werden ausgeworfen, wenn wir etwas schreiben, was kein gültiger JavaScript Code ist, zum Beispiel wenn wir uns vertippen und anstatt `return` `retrun` schreiben.\n\nReferenceErrors werden ausgeworfen, wenn JavaScript eine Referenz zu einem Wert nicht finden kann."},{"id":100,"question":" Was ist der Output?","codeSnippet":"// 🎉✨ Das ist unsere 100. Frage! ✨🎉\n\nconst output = `${[] && 'Im'}possible!\nYou should${'' && `n't`} see a therapist after so much JavaScript lol`","answerOptions":{"A":"`possible! You should see a therapist after so much JavaScript lol`","B":"`Impossible! You should see a therapist after so much JavaScript lol`","C":"`possible! You shouldn't see a therapist after so much JavaScript lol`","D":"`Impossible! You shouldn't see a therapist after so much JavaScript lol`"},"correctAnswer":"B","answerExplanation":"`[]` ist ein \"truthy\" Wert. Mit dem `&&` Operator geben wir den rechten Wert aus, wenn der linke truthy ist. In diesem Fall ist `[]` truthy, wodurch `\"Im'` ausgegeben wird.\n\n`\"\"` ein ein \"falsy\" Wert. Wenn der linke Wert falsy ist wird nichts ausgegeben. In diesem Fall wird `n't` _nicht_ ausgegeben."},{"id":101,"question":" Was ist der Output?","codeSnippet":"const one = (false || {} || null)\nconst two = (null || false || \"\")\nconst three = ([] || 0 || true)\n\nconsole.log(one, two, three)","answerOptions":{"A":"`false` `null` `[]`","B":"`null` `\"\"` `true`","C":"`{}` `\"\"` `[]`","D":"`null` `null` `true`"},"correctAnswer":"C","answerExplanation":"Mit dem `||` Operator geben wir den ersten truthy Operand aus. Wenn alle Werte falsy sind wird der letzte Operand ausgegeben.\n\n`(false || {} || null)`: das leere Objekt `{}` ist truthy. Das ist der erste und einzige truthy Wert und wird daher ausgegeben. `one` ist gleich `{}`.\n\n`(null || false || \"\")`: alle Operanden sind falsy. Das bedeutet, dass der letzte Wert `\"\"` ausgegeben wird. `two` ist gleich `\"\"`.\n\n`([] || 0 || \"\")`: das leere Array `[]` ist truthy. Das ist der erste truthy Wert, und wird daher ausgegeben. `three` ist gleich `[]`."},{"id":102,"question":" What's the value of output?","codeSnippet":"const myPromise = () => Promise.resolve('I have resolved!')\n\nfunction firstFunction() {\n  myPromise().then(res => console.log(res))\n  console.log('second')\n}\n\nasync function secondFunction() {\n  console.log(await myPromise())\n  console.log('second')\n}","answerOptions":{"A":"`I have resolved!`, `second` und `I have resolved!`, `second`","B":"`second`, `I have resolved!` und `second`, `I have resolved!`","C":"`I have resolved!`, `second` und `second`, `I have resolved!`","D":"`second`, `I have resolved!` und `I have resolved!`, `second`"},"correctAnswer":"D","answerExplanation":"Mit einem Promise sagen wir _Ich möchte diese Funktion ausführen, aber ich lege sie erstmal beiseite, weil sie eine Weile braucht. Erst wenn ein bestimmter Wert ausgegeben (oder rejected) wird und der Call Stack leer ist möchte ich den Wert nutzen._\n\nWir können auf den Wert mit `.then()` oder `await` in einer `async` Funktion zugreifen, aber `.then()` und `await` unterscheiden sich in einem bestimmten Punkt.\n\nIn `firstFunction` legen wir `myPromise` beiseite, während die Funktion durchläuft, aber wir arbeiten anderen Code ab, hier `console.log('second')`. \nDann wird die Funktion abgeschlossen und der String `I have resolved` wird ausgegeben, nachdem sich der Call Stack geleert hat. \n\nMit dem `await` Keyword in `secondFunction` wird die Funktion gestoppt bis der Wert ausgegeben wurde, erst dann wird die nächste Zeile ausgeführt.\n\nDas bedeutet, dass auf `myPromise` gewartet und dann der Wert `I have resolved` ausgegeben wird und erst dann wird die nächste Zeile ausgeführt und `second` wird geloggt."},{"id":103,"question":" Was ist der Output?","codeSnippet":"const set = new Set()\n\nset.add(1)\nset.add(\"Lydia\")\nset.add({ name: \"Lydia\" })\n\nfor (let item of set) {\n  console.log(item + 2)\n}","answerOptions":{"A":"`3`, `NaN`, `NaN`","B":"`3`, `7`, `NaN`","C":"`3`, `Lydia2`, `[object Object]2`","D":"`\"12\"`, `Lydia2`, `[object Object]2`"},"correctAnswer":"C","answerExplanation":"Der `+` Operator wird nicht nur für numerische Werte verwendet, wir können mit ihm ebenso Strings zusammenfügen. Immer, wenn JavaScript merkt, dass mindestens ein Wert keine Nummer ist, wird ein String erstellt.\n\nDer erste Wert ist `1`, was ein numerischer Wert ist. `1 + 2` ergibt die Zahl `3`.\n\nDer zweite Wert hingegen ist der String `\"Lydia\"`. `\"Lydia\"` ist ein String und `2` ist eine Nummer: `2` wird in einem String umgewandelt. `\"Lydia\"` und `\"2\"` werden zusammengesetzt, was den String `\"Lydia2\"` ausgibt. \n\n`{ name: \"Lydia\" }` ist ein Objekt. Weder eine Nummer, noch ein Objekt sind ein String, aber beide werden zu Strings konvertiert und `\"[object Object]\"` wird ausgegeben. `\"[object Object]\"` zusammengesetzt mit `\"2\"` wird `\"[object Object]2\"`."},{"id":104,"question":" Was wird ausgegeben?","codeSnippet":"Promise.resolve(5)","answerOptions":{"A":"`5`","B":"`Promise {<pending>: 5}`","C":"`Promise {<resolved>: 5}`","D":"`Error`"},"correctAnswer":"C","answerExplanation":"Wir können jeden Wert an `Promise.resolve` übergeben, es muss nicht unbedingt ein Promise sein. Die Methode selbst gibt ein Promise zurück, was einen Wert ausgibt. Wenn man eine normale Funktion übergibt wird das Promise einen normalen Wert ausgeben. Wenn ein Promise übergeben wird so wird ein Promise gelöst und der Wert des gelösten Promises ausgegeben.\n\nIn diesem Fall haben wir nur die Zahl `5` übergeben und diese wird genauso ausgegeben: `5`."},{"id":105,"question":" Was wird ausgegeben?","codeSnippet":"function compareMembers(person1, person2 = person) {\n  if (person1 !== person2) {\n    console.log(\"Not the same!\")\n  } else {\n    console.log(\"They are the same!\")\n  }\n}\n\nconst person = { name: \"Lydia\" }\n\ncompareMembers(person)","answerOptions":{"A":"`Not the same!`","B":"`They are the same!`","C":"`ReferenceError`","D":"`SyntaxError`"},"correctAnswer":"B","answerExplanation":"Objekte werden durch eine Referenz übergeben. Wenn wir Objekte auf strikte Gleichheit (`===`) prüfen, vergleichen wir nur deren Referenz.\n\nWir setzen den Standardwert für `person2` gleich dem `person` Objekt und übergeben dem `person` Objekt den Wert von `person1`.\n\nDas bedeutet, dass beide Werte eine Referenz zum gleichen Ort im Speicher aufweisen und daher gleich sind.\n\nDer Code im `else` Statement wird aufgerufen und `They are the same!` wird geloggt."},{"id":106,"question":" Was wird ausgegeben?","codeSnippet":"const colorConfig = {\n  red: true,\n  blue: false,\n  green: true,\n  black: true,\n  yellow: false,\n}\n\nconst colors = [\"pink\", \"red\", \"blue\"]\n\nconsole.log(colorConfig.colors[1])","answerOptions":{"A":"`true`","B":"`false`","C":"`undefined`","D":"`TypeError`"},"correctAnswer":"D","answerExplanation":"In JavaScript gibt es zwei Wege auf Properties an Objekten zuzugreifen: Punkt-Notation oder Klammern-Notation. In diesem Beispiel nutzen wir Punkt-Notation (`colorConfig.colors`) anstelle von Klammern-Notation (`colorConfig[\"colors\"]`). \n\nMit Punkt-Notation versucht JavaScript die Property am Objekt mit diesem exakten Namen zu finden. In unserem Beispiel `colors` im `colorConfig` Objekt. Da es keine Property `colorConfig` gibt wird `undefined` ausgegeben. Dann versuchen wir den Wert des ersten Elements mit `[1]` aufzurufen, was an `undefined` nicht möglich ist, wodurch wir `TypeError: Cannot read property '1' of undefined` ausgegeben bekommen.\n\nJavaScript interpretiert Statements. Wenn wir Klammern-Notation verwenden wird die erste Klammer `[` gefunden und JavaScript sucht solange, bis eine schließende Klammer `]` gefunden wird. Erst dann wird das Statement interpretiert. Hätten wir `colorConfig[colors[1]]` verwendet, wäre der Wert `red` ausgegeben worden."},{"id":107,"question":" Was wird ausgegeben?","codeSnippet":"console.log('❤️' === '❤️')","answerOptions":{"A":"`true`","B":"`false`"},"correctAnswer":"A","answerExplanation":"Emojis sind im Endeffekt nur Unicodes. Der Unicode für das Herz Emoji ist `\"U+2764 U+FE0F\"`. Dieser ist immer gleich, für das selbe Emoji und daher wird `true` ausgegeben."},{"id":108,"question":" Welche Methode verändert das ursprüngliche Array? ","codeSnippet":"const emojis = ['✨', '🥑', '😍']\n\nemojis.map(x => x + '✨')\nemojis.filter(x => x !== '🥑')\nemojis.find(x => x !== '🥑')\nemojis.reduce((acc, cur) => acc + '✨')\nemojis.slice(1, 2, '✨') \nemojis.splice(1, 2, '✨')","answerOptions":{"A":"`All of them`","B":"`map` `reduce` `slice` `splice`","C":"`map` `slice` `splice`","D":"`splice`"},"correctAnswer":"D","answerExplanation":"Mit der `splice` Methode ändern wir das ursprüngliche Array durch löschen, ersetzen oder ergänzen von Elementen. In diesem Fall haben wir 2 Elemente vom Index 1 (`'🥑'` und `'😍'`) entfernt und ✨ stattdessen eingefügt. \n\n`map`, `filter` und `slice` geben ein neues Array aus, `find` gibt ein Element aus und `reduce` gibt einen neuen Wert aus."},{"id":109,"question":" Was ist der Output?","codeSnippet":"const food = ['🍕', '🍫', '🥑', '🍔']\nconst info = { favoriteFood: food[0] }\n\ninfo.favoriteFood = '🍝'\n\nconsole.log(food)","answerOptions":{"A":"`['🍕', '🍫', '🥑', '🍔']`","B":"`['🍝', '🍫', '🥑', '🍔']`","C":"`['🍝', '🍕', '🍫', '🥑', '🍔']`","D":"`ReferenceError`"},"correctAnswer":"A","answerExplanation":"In JavaScript interagieren primitive Datentypen (alles außer Objekte) anhand des _Wertes_. In diesem Beispiel setzen wir den Wert von `favoriteFood` am `info` Objekt gleich dem Wert des ersten Elements im `food` Array, in dem Fall ein String mit dem Pizza Emoji (`'🍕'`). Ein String ist ein primitiver Datentyp und agiert daher in JavaScript nach Referenz. (Siehe mein [Blogpost](https://www.theavocoder.com/complete-javascript/2018/12/21/by-value-vs-by-reference) für mehr Informationen)\n\nDann ändern wir den Wert von `favoriteFood` am `info` Objekt. Das `food` Array hat sich nicht verändert, da der Wert von `favoriteFood` nur eine _Kopie_ des Wertes des ersten Elements im Array war und keine Referenz zum Element `food[0]` im Speicher finden kann. Wenn wir also das Essen loggen ist es immernoch das ursprüngliche Array `['🍕', '🍫', '🥑', '🍔']`."},{"id":110,"question":" Was macht diese Methode?","codeSnippet":"JSON.parse()","answerOptions":{"A":"Parsed JSON in einen JavaScript Wert","B":"Parsed ein JavaScript Objekt zu JSON","C":"Parsed jegliche JavaScript Werte zu JSON","D":"Parsed JSON zu jeglichem JavaScript Objekt"},"correctAnswer":"A","answerExplanation":"Mit der `JSON.parse()` Methode können wir einen JSON String zu einem JavaScript Wert umwandeln.\n\n```javascript\n// Stringifying a number into valid JSON, then parsing the JSON string to a JavaScript value:\nconst jsonNumber = JSON.stringify(4) // '4'\nJSON.parse(jsonNumber) // 4\n\n// Stringifying an array value into valid JSON, then parsing the JSON string to a JavaScript value:\nconst jsonArray = JSON.stringify([1, 2, 3]) // '[1, 2, 3]'\nJSON.parse(jsonArray) // [1, 2, 3]\n\n// Stringifying an object  into valid JSON, then parsing the JSON string to a JavaScript value:\nconst jsonArray = JSON.stringify({ name: \"Lydia\" }) // '{\"name\":\"Lydia\"}'\nJSON.parse(jsonArray) // { name: 'Lydia' }\n```"},{"id":111,"question":" Was ist der Output? ","codeSnippet":"let name = 'Lydia'\n\nfunction getName() {\n  console.log(name)\n  let name = 'Sarah'\n}\n\ngetName()","answerOptions":{"A":"Lydia","B":"Sarah","C":"`undefined`","D":"`ReferenceError`"},"correctAnswer":"D","answerExplanation":"Jede Funktion hat ihren eigenen _Ausführungskontext_ (oder _scope_). Die `getName` Funktion sucht zuerst in ihrem eigenen Kontext (scope) um zu sehen, ob sie den Wert `name` finden kann. In diesem Fall beinhaltet die `getName` Funktion ihre eigene Variable `name`: wir setzen die Variable `name` mit dem `let` Keyword und dem Wert `'Sarah'`.\n\nVariablen mit dem `let` und `const` Keyword werden gehoisted, aber entgegen `var` werden diese nicht _initialisiert_. Sie sind nicht aufrufbar, bevor wir sie deklarieren (initialisieren). Das ist eine \"vorübergehende tote Zone\" (temporal dead zone). Wir bekommen einen `ReferenceError` ausgegeben.\n\nHätten wir die `name` Variable nicht innerhalb `getName` deklariert, so hätte JavaScript außerhalb der Funktion in der _Scope-Kette_ weitergesucht. Der äußere Scope beinhaltet ebenfalls eine Variable `name` mit dem Wert `'Lydia'`. In diesem Fall wäre `Lydia` geloggt worden.\n\n```javascript\nlet name = 'Lydia'\n\nfunction getName() {\n  console.log(name)\n}\n\ngetName() // Lydia\n```"},{"id":112,"question":" Was ist der Output?","codeSnippet":"function* generatorOne() {\n  yield ['a', 'b', 'c'];\n}\n\nfunction* generatorTwo() {\n  yield* ['a', 'b', 'c'];\n}\n\nconst one = generatorOne()\nconst two = generatorTwo()\n\nconsole.log(one.next().value)\nconsole.log(two.next().value)","answerOptions":{"A":"`a` and `a`","B":"`a` and `undefined`","C":"`['a', 'b', 'c']` and `a`","D":"`a` and `['a', 'b', 'c']`"},"correctAnswer":"C","answerExplanation":"Mit dem `yield` Keyword, halten wir Werte in einer Generator-Funktion. Mit dem `yield*` Keyword können wir Werte einer anderen Generator-Funktion oder Objekte und Arrays halten.\n\nIn `generatorOne` halten wir das gesamte Array `['a', 'b', 'c']` mit dem `yield` Keyword. Der Wert von `value` am Objekt gibt die `next` Methode an `one` (`one.next().value`) aus, was dem gesamten Array entspricht: `['a', 'b', 'c']`.\n\n```javascript\nconsole.log(one.next().value) // ['a', 'b', 'c']\nconsole.log(one.next().value) // undefined\n```\n\nIn `generatorTwo` verwenden wir das `yield*` Keyword. Das bedeutet, dass der erste gehaltene Wert von `two` gleich dem ersten gehaltenen Wert ist. Das ist das Array `['a', 'b', 'c']`. Der erste gehaltene Wert ist `a`, was ausgegeben wird.\n\n```javascript\nconsole.log(two.next().value) // 'a'\nconsole.log(two.next().value) // 'b'\nconsole.log(two.next().value) // 'c'\nconsole.log(two.next().value) // undefined\n```"},{"id":113,"question":" Was ist der Output?","codeSnippet":"console.log(`${(x => x)('I love')} to program`)","answerOptions":{"A":"`I love to program`","B":"`undefined to program`","C":"`${(x => x)('I love') to program`","D":"`TypeError`"},"correctAnswer":"A","answerExplanation":"Expressions innerhalb von Template Literals werden zuerst berechnet. Das bedeutet, dass der String den ausgegebenen Wert der Expression beinhaltet, hier die IIFE (immediately invoked Function) `(x => x)('I love')`. Wir geben den Wert `'I love'` als Argument an die `x => x` Arrow Funktion. `x` ist gleich `'I love'` und wird ausgegeben. Das Ergebnis ist `I love to program`."},{"id":114,"question":" What will happen?","codeSnippet":"let config = {\n  alert: setInterval(() => {\n    console.log('Alert!)\n  }, 1000)\n}\n\nconfig = null","answerOptions":{"A":"Die `setInterval` Callback Funktion wird nicht aufgerufen","B":"Die `setInterval` Callback Funktion wird ein Mal aufgerufen","C":"Die `setInterval` Callback Funktion wird weiterhin jede Sekunde aufgerufen","D":"Wir haben `config.alert()` nie aufgerufen, `config` ist `null`"},"correctAnswer":"C","answerExplanation":"Wenn wir normalerweise Objekte gleich `null` setzen, werden diese _verworfen_, weil keine Referenz mehr zu ihnen existiert. Da die Callback Funktion in `setInterval` eine Arrow Funktion (und daher an `config` gebunden) ist, hält die Callback Funktion immernoch eine Referenz zum `config` Objekt. Solange eine Referenz besteht, wird das Objekt nicht verworfen und die `setInterval` Funktion wird weiterhin alle 1000ms (1 Sekunde) aufgerufen."},{"id":115,"question":" Welche Methode(n) geben den Wert `'Hello world!'` aus?","codeSnippet":"const myMap = new Map()\nconst myFunc = () => 'greeting'\n\nmyMap.set(myFunc, 'Hello world!')\n\n//1\nmyMap.get('greeting')\n//2\nmyMap.get(myFunc)\n//3\nmyMap.get(() => 'greeting'))","answerOptions":{"A":"1","B":"2","C":"2 und 3","D":"Alle"},"correctAnswer":"B","answerExplanation":"Beim Setzen eines Key/Wert Paars mit der `set` Methode wird der Key als erstes Argument an die `set` Funktion übergeben und der Wert wird als zweites Argument eingegeben. Der Key ist die _Funktion_ `() => 'greeting'` und der Wert ist `'Hello world'`. `myMap` ist jetzt `{ () => 'greeting' => 'Hello world!' }`. \n\n1 ist falsch, weil der Key nicht `'greeting'`, sondern `() => 'greeting'` ist.\n3 ist falsch, weil wir eine neue Funktion erstellen, indem wir sie als Argument übergeben. Objekte interagieren anhand von _Referenzen_. Funktionen sind Objekte, weshalb zwei Funktionen streng gesehen nie gleich sind, selbst wenn sie sich nicht unterscheiden."},{"id":116,"question":" Was ist der Output?","codeSnippet":"const person = {\n  name: \"Lydia\",\n  age: 21\n}\n\nconst changeAge = (x = { ...person }) => x.age += 1\nconst changeAgeAndName = (x = { ...person }) => {\n  x.age += 1\n  x.name = \"Sarah\"\n}\n\nchangeAge(person)\nchangeAgeAndName()\n\nconsole.log(person)","answerOptions":{"A":"`{name: \"Sarah\", age: 22}`","B":"`{name: \"Sarah\", age: 23}`","C":"`{name: \"Lydia\", age: 22}`","D":"`{name: \"Lydia\", age: 23}`"},"correctAnswer":"C","answerExplanation":"Beide Funktionen, `changeAge` und `changeAgeAndName`, haben Standard Parameter, nämlich ein neu erstelltes Objekt `{ ...person }`. Dieses Objekt hat Kopien aller Key/Werte Paare im `person` Objekt.\n\nZuerst führen wir die `changeAge` Funktion aus und übergeben ihr das `person` Objekt als Argument. Daher wird `age` um 1 erhöht. `person` ist jetzt `{ name: \"Lydia\", age: 22 }`.\n\nDann führen wir `changeAgeAndName` aus, allerdings ohne Parameter. Stattdessen ist der Wert von `x` gleich dem neuen Objekt `{ ...person }`. Da dies ein neues Objekt ist hat es keinen Einfluss auf die Werte des `person` Objekts. `person` ist immernoch gleich `{ name: \"Lydia\", age: 22 }`."}]